import {
  __commonJS
} from "./chunk-ZS7NZCD4.js";

// node_modules/gridstack/dist/utils.js
var require_utils = __commonJS({
  "node_modules/gridstack/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Utils = exports.obsoleteAttr = exports.obsoleteOptsDel = exports.obsoleteOpts = exports.obsolete = void 0;
    function obsolete(self, f, oldName, newName, rev) {
      let wrapper = (...args) => {
        console.warn("gridstack.js: Function `" + oldName + "` is deprecated in " + rev + " and has been replaced with `" + newName + "`. It will be **completely** removed in v1.0");
        return f.apply(self, args);
      };
      wrapper.prototype = f.prototype;
      return wrapper;
    }
    exports.obsolete = obsolete;
    function obsoleteOpts(opts, oldName, newName, rev) {
      if (opts[oldName] !== void 0) {
        opts[newName] = opts[oldName];
        console.warn("gridstack.js: Option `" + oldName + "` is deprecated in " + rev + " and has been replaced with `" + newName + "`. It will be **completely** removed in v1.0");
      }
    }
    exports.obsoleteOpts = obsoleteOpts;
    function obsoleteOptsDel(opts, oldName, rev, info) {
      if (opts[oldName] !== void 0) {
        console.warn("gridstack.js: Option `" + oldName + "` is deprecated in " + rev + info);
      }
    }
    exports.obsoleteOptsDel = obsoleteOptsDel;
    function obsoleteAttr(el, oldName, newName, rev) {
      let oldAttr = el.getAttribute(oldName);
      if (oldAttr !== null) {
        el.setAttribute(newName, oldAttr);
        console.warn("gridstack.js: attribute `" + oldName + "`=" + oldAttr + " is deprecated on this object in " + rev + " and has been replaced with `" + newName + "`. It will be **completely** removed in v1.0");
      }
    }
    exports.obsoleteAttr = obsoleteAttr;
    var Utils = class _Utils {
      /** convert a potential selector into actual list of html elements */
      static getElements(els) {
        if (typeof els === "string") {
          let list = document.querySelectorAll(els);
          if (!list.length && els[0] !== "." && els[0] !== "#") {
            list = document.querySelectorAll("." + els);
            if (!list.length) {
              list = document.querySelectorAll("#" + els);
            }
          }
          return Array.from(list);
        }
        return [els];
      }
      /** convert a potential selector into actual single element */
      static getElement(els) {
        if (typeof els === "string") {
          if (!els.length)
            return null;
          if (els[0] === "#") {
            return document.getElementById(els.substring(1));
          }
          if (els[0] === "." || els[0] === "[") {
            return document.querySelector(els);
          }
          if (!isNaN(+els[0])) {
            return document.getElementById(els);
          }
          let el = document.querySelector(els);
          if (!el) {
            el = document.getElementById(els);
          }
          if (!el) {
            el = document.querySelector("." + els);
          }
          return el;
        }
        return els;
      }
      /** returns true if a and b overlap */
      static isIntercepted(a, b) {
        return !(a.y >= b.y + b.h || a.y + a.h <= b.y || a.x + a.w <= b.x || a.x >= b.x + b.w);
      }
      /** returns true if a and b touch edges or corners */
      static isTouching(a, b) {
        return _Utils.isIntercepted(a, { x: b.x - 0.5, y: b.y - 0.5, w: b.w + 1, h: b.h + 1 });
      }
      /**
       * Sorts array of nodes
       * @param nodes array to sort
       * @param dir 1 for asc, -1 for desc (optional)
       * @param width width of the grid. If undefined the width will be calculated automatically (optional).
       **/
      static sort(nodes, dir, column) {
        column = column || nodes.reduce((col, n) => Math.max(n.x + n.w, col), 0) || 12;
        if (dir === -1)
          return nodes.sort((a, b) => b.x + b.y * column - (a.x + a.y * column));
        else
          return nodes.sort((b, a) => b.x + b.y * column - (a.x + a.y * column));
      }
      /**
       * creates a style sheet with style id under given parent
       * @param id will set the 'gs-style-id' attribute to that id
       * @param parent to insert the stylesheet as first child,
       * if none supplied it will be appended to the document head instead.
       */
      static createStylesheet(id, parent) {
        let style = document.createElement("style");
        style.setAttribute("type", "text/css");
        style.setAttribute("gs-style-id", id);
        if (style.styleSheet) {
          style.styleSheet.cssText = "";
        } else {
          style.appendChild(document.createTextNode(""));
        }
        if (!parent) {
          parent = document.getElementsByTagName("head")[0];
          parent.appendChild(style);
        } else {
          parent.insertBefore(style, parent.firstChild);
        }
        return style.sheet;
      }
      /** removed the given stylesheet id */
      static removeStylesheet(id) {
        let el = document.querySelector("STYLE[gs-style-id=" + id + "]");
        if (el && el.parentNode)
          el.remove();
      }
      /** inserts a CSS rule */
      static addCSSRule(sheet, selector, rules) {
        if (typeof sheet.addRule === "function") {
          sheet.addRule(selector, rules);
        } else if (typeof sheet.insertRule === "function") {
          sheet.insertRule(`${selector}{${rules}}`);
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static toBool(v) {
        if (typeof v === "boolean") {
          return v;
        }
        if (typeof v === "string") {
          v = v.toLowerCase();
          return !(v === "" || v === "no" || v === "false" || v === "0");
        }
        return Boolean(v);
      }
      static toNumber(value) {
        return value === null || value.length === 0 ? void 0 : Number(value);
      }
      static parseHeight(val) {
        let h;
        let unit = "px";
        if (typeof val === "string") {
          let match = val.match(/^(-[0-9]+\.[0-9]+|[0-9]*\.[0-9]+|-[0-9]+|[0-9]+)(px|em|rem|vh|vw|%)?$/);
          if (!match) {
            throw new Error("Invalid height");
          }
          unit = match[2] || "px";
          h = parseFloat(match[1]);
        } else {
          h = val;
        }
        return { h, unit };
      }
      /** copies unset fields in target to use the given default sources values */
      // eslint-disable-next-line
      static defaults(target, ...sources) {
        sources.forEach((source) => {
          for (const key in source) {
            if (!source.hasOwnProperty(key))
              return;
            if (target[key] === null || target[key] === void 0) {
              target[key] = source[key];
            } else if (typeof source[key] === "object" && typeof target[key] === "object") {
              this.defaults(target[key], source[key]);
            }
          }
        });
        return target;
      }
      /** given 2 objects return true if they have the same values. Checks for Object {} having same fields and values (just 1 level down) */
      static same(a, b) {
        if (typeof a !== "object")
          return a == b;
        if (typeof a !== typeof b)
          return false;
        if (Object.keys(a).length !== Object.keys(b).length)
          return false;
        for (const key in a) {
          if (a[key] !== b[key])
            return false;
        }
        return true;
      }
      /** copies over b size & position (GridStackPosition), and possibly min/max as well */
      static copyPos(a, b, doMinMax = false) {
        a.x = b.x;
        a.y = b.y;
        a.w = b.w;
        a.h = b.h;
        if (doMinMax) {
          if (b.minW)
            a.minW = b.minW;
          if (b.minH)
            a.minH = b.minH;
          if (b.maxW)
            a.maxW = b.maxW;
          if (b.maxH)
            a.maxH = b.maxH;
        }
        return a;
      }
      /** true if a and b has same size & position */
      static samePos(a, b) {
        return a && b && a.x === b.x && a.y === b.y && a.w === b.w && a.h === b.h;
      }
      /** removes field from the first object if same as the second objects (like diffing) and internal '_' for saving */
      static removeInternalAndSame(a, b) {
        if (typeof a !== "object" || typeof b !== "object")
          return;
        for (let key in a) {
          let val = a[key];
          if (key[0] === "_" || val === b[key]) {
            delete a[key];
          } else if (val && typeof val === "object" && b[key] !== void 0) {
            for (let i in val) {
              if (val[i] === b[key][i] || i[0] === "_") {
                delete val[i];
              }
            }
            if (!Object.keys(val).length) {
              delete a[key];
            }
          }
        }
      }
      /** return the closest parent (or itself) matching the given class */
      static closestByClass(el, name) {
        while (el) {
          if (el.classList.contains(name))
            return el;
          el = el.parentElement;
        }
        return null;
      }
      /** delay calling the given function for given delay, preventing new calls from happening while waiting */
      static throttle(func, delay) {
        let isWaiting = false;
        return (...args) => {
          if (!isWaiting) {
            isWaiting = true;
            setTimeout(() => {
              func(...args);
              isWaiting = false;
            }, delay);
          }
        };
      }
      static removePositioningStyles(el) {
        let style = el.style;
        if (style.position) {
          style.removeProperty("position");
        }
        if (style.left) {
          style.removeProperty("left");
        }
        if (style.top) {
          style.removeProperty("top");
        }
        if (style.width) {
          style.removeProperty("width");
        }
        if (style.height) {
          style.removeProperty("height");
        }
      }
      /** @internal returns the passed element if scrollable, else the closest parent that will, up to the entire document scrolling element */
      static getScrollElement(el) {
        if (!el)
          return document.scrollingElement || document.documentElement;
        const style = getComputedStyle(el);
        const overflowRegex = /(auto|scroll)/;
        if (overflowRegex.test(style.overflow + style.overflowY)) {
          return el;
        } else {
          return this.getScrollElement(el.parentElement);
        }
      }
      /** @internal */
      static updateScrollPosition(el, position, distance) {
        let rect = el.getBoundingClientRect();
        let innerHeightOrClientHeight = window.innerHeight || document.documentElement.clientHeight;
        if (rect.top < 0 || rect.bottom > innerHeightOrClientHeight) {
          let offsetDiffDown = rect.bottom - innerHeightOrClientHeight;
          let offsetDiffUp = rect.top;
          let scrollEl = this.getScrollElement(el);
          if (scrollEl !== null) {
            let prevScroll = scrollEl.scrollTop;
            if (rect.top < 0 && distance < 0) {
              if (el.offsetHeight > innerHeightOrClientHeight) {
                scrollEl.scrollTop += distance;
              } else {
                scrollEl.scrollTop += Math.abs(offsetDiffUp) > Math.abs(distance) ? distance : offsetDiffUp;
              }
            } else if (distance > 0) {
              if (el.offsetHeight > innerHeightOrClientHeight) {
                scrollEl.scrollTop += distance;
              } else {
                scrollEl.scrollTop += offsetDiffDown > distance ? distance : offsetDiffDown;
              }
            }
            position.top += scrollEl.scrollTop - prevScroll;
          }
        }
      }
      /**
       * @internal Function used to scroll the page.
       *
       * @param event `MouseEvent` that triggers the resize
       * @param el `HTMLElement` that's being resized
       * @param distance Distance from the V edges to start scrolling
       */
      static updateScrollResize(event, el, distance) {
        const scrollEl = this.getScrollElement(el);
        const height = scrollEl.clientHeight;
        const offsetTop = scrollEl === this.getScrollElement() ? 0 : scrollEl.getBoundingClientRect().top;
        const pointerPosY = event.clientY - offsetTop;
        const top = pointerPosY < distance;
        const bottom = pointerPosY > height - distance;
        if (top) {
          scrollEl.scrollBy({ behavior: "smooth", top: pointerPosY - distance });
        } else if (bottom) {
          scrollEl.scrollBy({ behavior: "smooth", top: distance - (height - pointerPosY) });
        }
      }
      /** single level clone, returning a new object with same top fields. This will share sub objects and arrays */
      static clone(obj) {
        if (obj === null || obj === void 0 || typeof obj !== "object") {
          return obj;
        }
        if (obj instanceof Array) {
          return [...obj];
        }
        return Object.assign({}, obj);
      }
      /**
       * Recursive clone version that returns a full copy, checking for nested objects and arrays ONLY.
       * Note: this will use as-is any key starting with double __ (and not copy inside) some lib have circular dependencies.
       */
      static cloneDeep(obj) {
        const ret = _Utils.clone(obj);
        for (const key in ret) {
          if (ret.hasOwnProperty(key) && typeof ret[key] === "object" && key.substring(0, 2) !== "__" && !skipFields.find((k) => k === key)) {
            ret[key] = _Utils.cloneDeep(obj[key]);
          }
        }
        return ret;
      }
    };
    exports.Utils = Utils;
    var skipFields = ["_isNested", "el", "grid", "subGrid", "engine"];
  }
});

// node_modules/gridstack/dist/gridstack-engine.js
var require_gridstack_engine = __commonJS({
  "node_modules/gridstack/dist/gridstack-engine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridStackEngine = void 0;
    var utils_1 = require_utils();
    var GridStackEngine = class _GridStackEngine {
      constructor(opts = {}) {
        this.addedNodes = [];
        this.removedNodes = [];
        this.column = opts.column || 12;
        this.maxRow = opts.maxRow;
        this._float = opts.float;
        this.nodes = opts.nodes || [];
        this.onChange = opts.onChange;
      }
      batchUpdate() {
        if (this.batchMode)
          return this;
        this.batchMode = true;
        this._prevFloat = this._float;
        this._float = true;
        return this.saveInitial();
      }
      commit() {
        if (!this.batchMode)
          return this;
        this.batchMode = false;
        this._float = this._prevFloat;
        delete this._prevFloat;
        return this._packNodes()._notify();
      }
      // use entire row for hitting area (will use bottom reverse sorted first) if we not actively moving DOWN and didn't already skip
      _useEntireRowArea(node, nn) {
        return !this.float && !this._hasLocked && (!node._moving || node._skipDown || nn.y <= node.y);
      }
      /** @internal fix collision on given 'node', going to given new location 'nn', with optional 'collide' node already found.
       * return true if we moved. */
      _fixCollisions(node, nn = node, collide, opt = {}) {
        this.sortNodes(-1);
        collide = collide || this.collide(node, nn);
        if (!collide)
          return false;
        if (node._moving && !opt.nested && !this.float) {
          if (this.swap(node, collide))
            return true;
        }
        let area = nn;
        if (this._useEntireRowArea(node, nn)) {
          area = { x: 0, w: this.column, y: nn.y, h: nn.h };
          collide = this.collide(node, area, opt.skip);
        }
        let didMove = false;
        let newOpt = { nested: true, pack: false };
        while (collide = collide || this.collide(node, area, opt.skip)) {
          let moved;
          if (collide.locked || node._moving && !node._skipDown && nn.y > node.y && !this.float && // can take space we had, or before where we're going
          (!this.collide(collide, Object.assign(Object.assign({}, collide), { y: node.y }), node) || !this.collide(collide, Object.assign(Object.assign({}, collide), { y: nn.y - collide.h }), node))) {
            node._skipDown = node._skipDown || nn.y > node.y;
            moved = this.moveNode(node, Object.assign(Object.assign(Object.assign({}, nn), { y: collide.y + collide.h }), newOpt));
            if (collide.locked && moved) {
              utils_1.Utils.copyPos(nn, node);
            } else if (!collide.locked && moved && opt.pack) {
              this._packNodes();
              nn.y = collide.y + collide.h;
              utils_1.Utils.copyPos(node, nn);
            }
            didMove = didMove || moved;
          } else {
            moved = this.moveNode(collide, Object.assign(Object.assign(Object.assign({}, collide), { y: nn.y + nn.h, skip: node }), newOpt));
          }
          if (!moved) {
            return didMove;
          }
          collide = void 0;
        }
        return didMove;
      }
      /** return the nodes that intercept the given node. Optionally a different area can be used, as well as a second node to skip */
      collide(skip, area = skip, skip2) {
        return this.nodes.find((n) => n !== skip && n !== skip2 && utils_1.Utils.isIntercepted(n, area));
      }
      collideAll(skip, area = skip, skip2) {
        return this.nodes.filter((n) => n !== skip && n !== skip2 && utils_1.Utils.isIntercepted(n, area));
      }
      /** does a pixel coverage collision, returning the node that has the most coverage that is >50% mid line */
      collideCoverage(node, o, collides) {
        if (!o.rect || !node._rect)
          return;
        let r0 = node._rect;
        let r = Object.assign({}, o.rect);
        if (r.y > r0.y) {
          r.h += r.y - r0.y;
          r.y = r0.y;
        } else {
          r.h += r0.y - r.y;
        }
        if (r.x > r0.x) {
          r.w += r.x - r0.x;
          r.x = r0.x;
        } else {
          r.w += r0.x - r.x;
        }
        let collide;
        collides.forEach((n) => {
          if (n.locked || !n._rect)
            return;
          let r2 = n._rect;
          let yOver = Number.MAX_VALUE, xOver = Number.MAX_VALUE, overMax = 0.5;
          if (r0.y < r2.y) {
            yOver = (r.y + r.h - r2.y) / r2.h;
          } else if (r0.y + r0.h > r2.y + r2.h) {
            yOver = (r2.y + r2.h - r.y) / r2.h;
          }
          if (r0.x < r2.x) {
            xOver = (r.x + r.w - r2.x) / r2.w;
          } else if (r0.x + r0.w > r2.x + r2.w) {
            xOver = (r2.x + r2.w - r.x) / r2.w;
          }
          let over = Math.min(xOver, yOver);
          if (over > overMax) {
            overMax = over;
            collide = n;
          }
        });
        return collide;
      }
      /** called to cache the nodes pixel rectangles used for collision detection during drag */
      cacheRects(w, h, top, right, bottom, left) {
        this.nodes.forEach((n) => n._rect = {
          y: n.y * h + top,
          x: n.x * w + left,
          w: n.w * w - left - right,
          h: n.h * h - top - bottom
        });
        return this;
      }
      /** called to possibly swap between 2 nodes (same size or column, not locked, touching), returning true if successful */
      swap(a, b) {
        if (!b || b.locked || !a || a.locked)
          return false;
        function _doSwap() {
          let x = b.x, y = b.y;
          b.x = a.x;
          b.y = a.y;
          if (a.h != b.h) {
            a.x = x;
            a.y = b.y + b.h;
          } else if (a.w != b.w) {
            a.x = b.x + b.w;
            a.y = y;
          } else {
            a.x = x;
            a.y = y;
          }
          a._dirty = b._dirty = true;
          return true;
        }
        let touching;
        if (a.w === b.w && a.h === b.h && (a.x === b.x || a.y === b.y) && (touching = utils_1.Utils.isTouching(a, b)))
          return _doSwap();
        if (touching === false)
          return;
        if (a.w === b.w && a.x === b.x && (touching || (touching = utils_1.Utils.isTouching(a, b)))) {
          if (b.y < a.y) {
            let t = a;
            a = b;
            b = t;
          }
          return _doSwap();
        }
        if (touching === false)
          return;
        if (a.h === b.h && a.y === b.y && (touching || (touching = utils_1.Utils.isTouching(a, b)))) {
          if (b.x < a.x) {
            let t = a;
            a = b;
            b = t;
          }
          return _doSwap();
        }
        return false;
      }
      isAreaEmpty(x, y, w, h) {
        let nn = { x: x || 0, y: y || 0, w: w || 1, h: h || 1 };
        return !this.collide(nn);
      }
      /** re-layout grid items to reclaim any empty space */
      compact() {
        if (this.nodes.length === 0)
          return this;
        this.batchUpdate().sortNodes();
        let copyNodes = this.nodes;
        this.nodes = [];
        copyNodes.forEach((node) => {
          if (!node.locked) {
            node.autoPosition = true;
          }
          this.addNode(node, false);
          node._dirty = true;
        });
        return this.commit();
      }
      /** enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html) */
      set float(val) {
        if (this._float === val)
          return;
        this._float = val || false;
        if (!val) {
          this._packNodes()._notify();
        }
      }
      /** float getter method */
      get float() {
        return this._float || false;
      }
      /** sort the nodes array from first to last, or reverse. Called during collision/placement to force an order */
      sortNodes(dir) {
        this.nodes = utils_1.Utils.sort(this.nodes, dir, this.column);
        return this;
      }
      /** @internal called to top gravity pack the items back OR revert back to original Y positions when floating */
      _packNodes() {
        if (this.batchMode) {
          return this;
        }
        this.sortNodes();
        if (this.float) {
          this.nodes.forEach((n) => {
            if (n._updating || n._orig === void 0 || n.y === n._orig.y)
              return;
            let newY = n.y;
            while (newY > n._orig.y) {
              --newY;
              let collide = this.collide(n, { x: n.x, y: newY, w: n.w, h: n.h });
              if (!collide) {
                n._dirty = true;
                n.y = newY;
              }
            }
          });
        } else {
          this.nodes.forEach((n, i) => {
            if (n.locked)
              return;
            while (n.y > 0) {
              let newY = i === 0 ? 0 : n.y - 1;
              let canBeMoved = i === 0 || !this.collide(n, { x: n.x, y: newY, w: n.w, h: n.h });
              if (!canBeMoved)
                break;
              n._dirty = n.y !== newY;
              n.y = newY;
            }
          });
        }
        return this;
      }
      /**
       * given a random node, makes sure it's coordinates/values are valid in the current grid
       * @param node to adjust
       * @param resizing if out of bound, resize down or move into the grid to fit ?
       */
      prepareNode(node, resizing) {
        node = node || {};
        node._id = node._id || _GridStackEngine._idSeq++;
        if (node.x === void 0 || node.y === void 0 || node.x === null || node.y === null) {
          node.autoPosition = true;
        }
        let defaults = { x: 0, y: 0, w: 1, h: 1 };
        utils_1.Utils.defaults(node, defaults);
        if (!node.autoPosition) {
          delete node.autoPosition;
        }
        if (!node.noResize) {
          delete node.noResize;
        }
        if (!node.noMove) {
          delete node.noMove;
        }
        if (typeof node.x == "string") {
          node.x = Number(node.x);
        }
        if (typeof node.y == "string") {
          node.y = Number(node.y);
        }
        if (typeof node.w == "string") {
          node.w = Number(node.w);
        }
        if (typeof node.h == "string") {
          node.h = Number(node.h);
        }
        if (isNaN(node.x)) {
          node.x = defaults.x;
          node.autoPosition = true;
        }
        if (isNaN(node.y)) {
          node.y = defaults.y;
          node.autoPosition = true;
        }
        if (isNaN(node.w)) {
          node.w = defaults.w;
        }
        if (isNaN(node.h)) {
          node.h = defaults.h;
        }
        return this.nodeBoundFix(node, resizing);
      }
      /** part2 of preparing a node to fit inside our grid - checks  for x,y from grid dimensions */
      nodeBoundFix(node, resizing) {
        let before = node._orig || utils_1.Utils.copyPos({}, node);
        if (node.maxW) {
          node.w = Math.min(node.w, node.maxW);
        }
        if (node.maxH) {
          node.h = Math.min(node.h, node.maxH);
        }
        if (node.minW && node.minW <= this.column) {
          node.w = Math.max(node.w, node.minW);
        }
        if (node.minH) {
          node.h = Math.max(node.h, node.minH);
        }
        if (node.w > this.column) {
          if (this.column < 12 && !this._inColumnResize) {
            node.w = Math.min(12, node.w);
            this.cacheOneLayout(node, 12);
          }
          node.w = this.column;
        } else if (node.w < 1) {
          node.w = 1;
        }
        if (this.maxRow && node.h > this.maxRow) {
          node.h = this.maxRow;
        } else if (node.h < 1) {
          node.h = 1;
        }
        if (node.x < 0) {
          node.x = 0;
        }
        if (node.y < 0) {
          node.y = 0;
        }
        if (node.x + node.w > this.column) {
          if (resizing) {
            node.w = this.column - node.x;
          } else {
            node.x = this.column - node.w;
          }
        }
        if (this.maxRow && node.y + node.h > this.maxRow) {
          if (resizing) {
            node.h = this.maxRow - node.y;
          } else {
            node.y = this.maxRow - node.h;
          }
        }
        if (!utils_1.Utils.samePos(node, before)) {
          node._dirty = true;
        }
        return node;
      }
      /** returns a list of modified nodes from their original values */
      getDirtyNodes(verify) {
        if (verify) {
          return this.nodes.filter((n) => n._dirty && !utils_1.Utils.samePos(n, n._orig));
        }
        return this.nodes.filter((n) => n._dirty);
      }
      /** @internal call this to call onChange callback with dirty nodes so DOM can be updated */
      _notify(removedNodes) {
        if (this.batchMode || !this.onChange)
          return this;
        let dirtyNodes = (removedNodes || []).concat(this.getDirtyNodes());
        this.onChange(dirtyNodes);
        return this;
      }
      /** @internal remove dirty and last tried info */
      cleanNodes() {
        if (this.batchMode)
          return this;
        this.nodes.forEach((n) => {
          delete n._dirty;
          delete n._lastTried;
        });
        return this;
      }
      /** @internal called to save initial position/size to track real dirty state.
       * Note: should be called right after we call change event (so next API is can detect changes)
       * as well as right before we start move/resize/enter (so we can restore items to prev values) */
      saveInitial() {
        this.nodes.forEach((n) => {
          n._orig = utils_1.Utils.copyPos({}, n);
          delete n._dirty;
        });
        this._hasLocked = this.nodes.some((n) => n.locked);
        return this;
      }
      /** @internal restore all the nodes back to initial values (called when we leave) */
      restoreInitial() {
        this.nodes.forEach((n) => {
          if (utils_1.Utils.samePos(n, n._orig))
            return;
          utils_1.Utils.copyPos(n, n._orig);
          n._dirty = true;
        });
        this._notify();
        return this;
      }
      /** call to add the given node to our list, fixing collision and re-packing */
      addNode(node, triggerAddEvent = false) {
        let dup = this.nodes.find((n) => n._id === node._id);
        if (dup)
          return dup;
        node = this._inColumnResize ? this.nodeBoundFix(node) : this.prepareNode(node);
        delete node._temporaryRemoved;
        delete node._removeDOM;
        if (node.autoPosition) {
          this.sortNodes();
          for (let i = 0; ; ++i) {
            let x = i % this.column;
            let y = Math.floor(i / this.column);
            if (x + node.w > this.column) {
              continue;
            }
            let box = { x, y, w: node.w, h: node.h };
            if (!this.nodes.find((n) => utils_1.Utils.isIntercepted(box, n))) {
              node.x = x;
              node.y = y;
              delete node.autoPosition;
              break;
            }
          }
        }
        this.nodes.push(node);
        if (triggerAddEvent) {
          this.addedNodes.push(node);
        }
        this._fixCollisions(node);
        if (!this.batchMode) {
          this._packNodes()._notify();
        }
        return node;
      }
      removeNode(node, removeDOM = true, triggerEvent = false) {
        if (!this.nodes.find((n) => n === node)) {
          return this;
        }
        if (triggerEvent) {
          this.removedNodes.push(node);
        }
        if (removeDOM)
          node._removeDOM = true;
        this.nodes = this.nodes.filter((n) => n !== node);
        return this._packNodes()._notify([node]);
      }
      removeAll(removeDOM = true) {
        delete this._layouts;
        if (this.nodes.length === 0)
          return this;
        removeDOM && this.nodes.forEach((n) => n._removeDOM = true);
        this.removedNodes = this.nodes;
        this.nodes = [];
        return this._notify(this.removedNodes);
      }
      /** checks if item can be moved (layout constrain) vs moveNode(), returning true if was able to move.
       * In more complicated cases (maxRow) it will attempt at moving the item and fixing
       * others in a clone first, then apply those changes if still within specs. */
      moveNodeCheck(node, o) {
        if (!this.changedPosConstrain(node, o))
          return false;
        o.pack = true;
        if (!this.maxRow) {
          return this.moveNode(node, o);
        }
        let clonedNode;
        let clone = new _GridStackEngine({
          column: this.column,
          float: this.float,
          nodes: this.nodes.map((n) => {
            if (n === node) {
              clonedNode = Object.assign({}, n);
              return clonedNode;
            }
            return Object.assign({}, n);
          })
        });
        if (!clonedNode)
          return false;
        let canMove = clone.moveNode(clonedNode, o) && clone.getRow() <= this.maxRow;
        if (!canMove && !o.resizing) {
          let collide = this.collide(node, o);
          if (collide && this.swap(node, collide)) {
            this._notify();
            return true;
          }
        }
        if (!canMove)
          return false;
        clone.nodes.filter((n) => n._dirty).forEach((c) => {
          let n = this.nodes.find((a) => a._id === c._id);
          if (!n)
            return;
          utils_1.Utils.copyPos(n, c);
          n._dirty = true;
        });
        this._notify();
        return true;
      }
      /** return true if can fit in grid height constrain only (always true if no maxRow) */
      willItFit(node) {
        delete node._willFitPos;
        if (!this.maxRow)
          return true;
        let clone = new _GridStackEngine({
          column: this.column,
          float: this.float,
          nodes: this.nodes.map((n2) => {
            return Object.assign({}, n2);
          })
        });
        let n = Object.assign({}, node);
        this.cleanupNode(n);
        delete n.el;
        delete n._id;
        delete n.content;
        delete n.grid;
        clone.addNode(n);
        if (clone.getRow() <= this.maxRow) {
          node._willFitPos = utils_1.Utils.copyPos({}, n);
          return true;
        }
        return false;
      }
      /** true if x,y or w,h are different after clamping to min/max */
      changedPosConstrain(node, p) {
        p.w = p.w || node.w;
        p.h = p.h || node.h;
        if (node.x !== p.x || node.y !== p.y)
          return true;
        if (node.maxW) {
          p.w = Math.min(p.w, node.maxW);
        }
        if (node.maxH) {
          p.h = Math.min(p.h, node.maxH);
        }
        if (node.minW) {
          p.w = Math.max(p.w, node.minW);
        }
        if (node.minH) {
          p.h = Math.max(p.h, node.minH);
        }
        return node.w !== p.w || node.h !== p.h;
      }
      /** return true if the passed in node was actually moved (checks for no-op and locked) */
      moveNode(node, o) {
        if (!node || /*node.locked ||*/
        !o)
          return false;
        if (o.pack === void 0)
          o.pack = true;
        if (typeof o.x !== "number") {
          o.x = node.x;
        }
        if (typeof o.y !== "number") {
          o.y = node.y;
        }
        if (typeof o.w !== "number") {
          o.w = node.w;
        }
        if (typeof o.h !== "number") {
          o.h = node.h;
        }
        let resizing = node.w !== o.w || node.h !== o.h;
        let nn = utils_1.Utils.copyPos({}, node, true);
        utils_1.Utils.copyPos(nn, o);
        nn = this.nodeBoundFix(nn, resizing);
        utils_1.Utils.copyPos(o, nn);
        if (utils_1.Utils.samePos(node, o))
          return false;
        let prevPos = utils_1.Utils.copyPos({}, node);
        let collides = this.collideAll(node, nn, o.skip);
        let needToMove = true;
        if (collides.length) {
          let collide = node._moving && !o.nested ? this.collideCoverage(node, o, collides) : collides[0];
          if (collide) {
            needToMove = !this._fixCollisions(node, nn, collide, o);
          } else {
            needToMove = false;
          }
        }
        if (needToMove) {
          node._dirty = true;
          utils_1.Utils.copyPos(node, nn);
        }
        if (o.pack) {
          this._packNodes()._notify();
        }
        return !utils_1.Utils.samePos(node, prevPos);
      }
      getRow() {
        return this.nodes.reduce((row, n) => Math.max(row, n.y + n.h), 0);
      }
      beginUpdate(node) {
        if (!node._updating) {
          node._updating = true;
          delete node._skipDown;
          if (!this.batchMode)
            this.saveInitial();
        }
        return this;
      }
      endUpdate() {
        let n = this.nodes.find((n2) => n2._updating);
        if (n) {
          delete n._updating;
          delete n._skipDown;
        }
        return this;
      }
      /** saves a copy of the largest column layout (eg 12 even when rendering oneColumnMode, so we don't loose orig layout),
       * returning a list of widgets for serialization */
      save(saveElement = true) {
        var _a;
        let len = (_a = this._layouts) === null || _a === void 0 ? void 0 : _a.length;
        let layout = len && this.column !== len - 1 ? this._layouts[len - 1] : null;
        let list = [];
        this.sortNodes();
        this.nodes.forEach((n) => {
          let wl = layout === null || layout === void 0 ? void 0 : layout.find((l) => l._id === n._id);
          let w = Object.assign({}, n);
          if (wl) {
            w.x = wl.x;
            w.y = wl.y;
            w.w = wl.w;
          }
          for (let key in w) {
            if (key[0] === "_" || w[key] === null || w[key] === void 0)
              delete w[key];
          }
          delete w.grid;
          if (!saveElement)
            delete w.el;
          if (!w.autoPosition)
            delete w.autoPosition;
          if (!w.noResize)
            delete w.noResize;
          if (!w.noMove)
            delete w.noMove;
          if (!w.locked)
            delete w.locked;
          list.push(w);
        });
        return list;
      }
      /** @internal called whenever a node is added or moved - updates the cached layouts */
      layoutsNodesChange(nodes) {
        if (!this._layouts || this._inColumnResize)
          return this;
        this._layouts.forEach((layout, column) => {
          if (!layout || column === this.column)
            return this;
          if (column < this.column) {
            this._layouts[column] = void 0;
          } else {
            let ratio = column / this.column;
            nodes.forEach((node) => {
              if (!node._orig)
                return;
              let n = layout.find((l) => l._id === node._id);
              if (!n)
                return;
              if (node.y !== node._orig.y) {
                n.y += node.y - node._orig.y;
              }
              if (node.x !== node._orig.x) {
                n.x = Math.round(node.x * ratio);
              }
              if (node.w !== node._orig.w) {
                n.w = Math.round(node.w * ratio);
              }
            });
          }
        });
        return this;
      }
      /**
       * @internal Called to scale the widget width & position up/down based on the column change.
       * Note we store previous layouts (especially original ones) to make it possible to go
       * from say 12 -> 1 -> 12 and get back to where we were.
       *
       * @param prevColumn previous number of columns
       * @param column  new column number
       * @param nodes different sorted list (ex: DOM order) instead of current list
       * @param layout specify the type of re-layout that will happen (position, size, etc...).
       * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column
       */
      updateNodeWidths(prevColumn, column, nodes, layout = "moveScale") {
        var _a;
        if (!this.nodes.length || !column || prevColumn === column)
          return this;
        this.cacheLayout(this.nodes, prevColumn);
        this.batchUpdate();
        let newNodes = [];
        let domOrder = false;
        if (column === 1 && (nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
          domOrder = true;
          let top = 0;
          nodes.forEach((n) => {
            n.x = 0;
            n.w = 1;
            n.y = Math.max(n.y, top);
            top = n.y + n.h;
          });
          newNodes = nodes;
          nodes = [];
        } else {
          nodes = utils_1.Utils.sort(this.nodes, -1, prevColumn);
        }
        let cacheNodes = [];
        if (column > prevColumn) {
          cacheNodes = this._layouts[column] || [];
          let lastIndex = this._layouts.length - 1;
          if (!cacheNodes.length && prevColumn !== lastIndex && ((_a = this._layouts[lastIndex]) === null || _a === void 0 ? void 0 : _a.length)) {
            prevColumn = lastIndex;
            this._layouts[lastIndex].forEach((cacheNode) => {
              let n = nodes.find((n2) => n2._id === cacheNode._id);
              if (n) {
                n.x = cacheNode.x;
                n.y = cacheNode.y;
                n.w = cacheNode.w;
              }
            });
          }
        }
        cacheNodes.forEach((cacheNode) => {
          let j = nodes.findIndex((n) => n._id === cacheNode._id);
          if (j !== -1) {
            nodes[j].x = cacheNode.x;
            nodes[j].y = cacheNode.y;
            nodes[j].w = cacheNode.w;
            newNodes.push(nodes[j]);
            nodes.splice(j, 1);
          }
        });
        if (nodes.length) {
          if (typeof layout === "function") {
            layout(column, prevColumn, newNodes, nodes);
          } else if (!domOrder) {
            let ratio = column / prevColumn;
            let move = layout === "move" || layout === "moveScale";
            let scale = layout === "scale" || layout === "moveScale";
            nodes.forEach((node) => {
              node.x = column === 1 ? 0 : move ? Math.round(node.x * ratio) : Math.min(node.x, column - 1);
              node.w = column === 1 || prevColumn === 1 ? 1 : scale ? Math.round(node.w * ratio) || 1 : Math.min(node.w, column);
              newNodes.push(node);
            });
            nodes = [];
          }
        }
        newNodes = utils_1.Utils.sort(newNodes, -1, column);
        this._inColumnResize = true;
        this.nodes = [];
        newNodes.forEach((node) => {
          this.addNode(node, false);
          delete node._orig;
        });
        this.commit();
        delete this._inColumnResize;
        return this;
      }
      /**
       * call to cache the given layout internally to the given location so we can restore back when column changes size
       * @param nodes list of nodes
       * @param column corresponding column index to save it under
       * @param clear if true, will force other caches to be removed (default false)
       */
      cacheLayout(nodes, column, clear = false) {
        let copy = [];
        nodes.forEach((n, i) => {
          n._id = n._id || _GridStackEngine._idSeq++;
          copy[i] = { x: n.x, y: n.y, w: n.w, _id: n._id };
        });
        this._layouts = clear ? [] : this._layouts || [];
        this._layouts[column] = copy;
        return this;
      }
      /**
       * call to cache the given node layout internally to the given location so we can restore back when column changes size
       * @param node single node to cache
       * @param column corresponding column index to save it under
       */
      cacheOneLayout(n, column) {
        n._id = n._id || _GridStackEngine._idSeq++;
        let layout = { x: n.x, y: n.y, w: n.w, _id: n._id };
        this._layouts = this._layouts || [];
        this._layouts[column] = this._layouts[column] || [];
        let index = this._layouts[column].findIndex((l) => l._id === n._id);
        index === -1 ? this._layouts[column].push(layout) : this._layouts[column][index] = layout;
        return this;
      }
      /** called to remove all internal values but the _id */
      cleanupNode(node) {
        for (let prop in node) {
          if (prop[0] === "_" && prop !== "_id")
            delete node[prop];
        }
        return this;
      }
    };
    exports.GridStackEngine = GridStackEngine;
    GridStackEngine._idSeq = 1;
  }
});

// node_modules/gridstack/dist/gridstack-ddi.js
var require_gridstack_ddi = __commonJS({
  "node_modules/gridstack/dist/gridstack-ddi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridStackDDI = void 0;
    var GridStackDDI = class _GridStackDDI {
      /** call this method to register your plugin instead of the default no-op one */
      static registerPlugin(pluginClass) {
        _GridStackDDI.ddi = new pluginClass();
        return _GridStackDDI.ddi;
      }
      /** get the current registered plugin to use */
      static get() {
        return _GridStackDDI.ddi || _GridStackDDI.registerPlugin(_GridStackDDI);
      }
      /** removes any drag&drop present (called during destroy) */
      /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
      remove(el) {
        return this;
      }
    };
    exports.GridStackDDI = GridStackDDI;
  }
});

// node_modules/gridstack/dist/types.js
var require_types = __commonJS({
  "node_modules/gridstack/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/gridstack/dist/gridstack.js
var require_gridstack = __commonJS({
  "node_modules/gridstack/dist/gridstack.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridStack = void 0;
    var gridstack_engine_1 = require_gridstack_engine();
    var utils_1 = require_utils();
    var gridstack_ddi_1 = require_gridstack_ddi();
    __exportStar(require_types(), exports);
    __exportStar(require_utils(), exports);
    __exportStar(require_gridstack_engine(), exports);
    __exportStar(require_gridstack_ddi(), exports);
    var GridDefaults = {
      column: 12,
      minRow: 0,
      maxRow: 0,
      itemClass: "grid-stack-item",
      placeholderClass: "grid-stack-placeholder",
      placeholderText: "",
      handle: ".grid-stack-item-content",
      handleClass: null,
      styleInHead: false,
      cellHeight: "auto",
      cellHeightThrottle: 100,
      margin: 10,
      auto: true,
      oneColumnSize: 768,
      float: false,
      staticGrid: false,
      animate: true,
      alwaysShowResizeHandle: false,
      resizable: {
        autoHide: true,
        handles: "se"
      },
      draggable: {
        handle: ".grid-stack-item-content",
        scroll: false,
        appendTo: "body"
      },
      disableDrag: false,
      disableResize: false,
      rtl: "auto",
      removable: false,
      removableOptions: {
        accept: ".grid-stack-item"
      },
      marginUnit: "px",
      cellHeightUnit: "px",
      disableOneColumnMode: false,
      oneColumnModeDomSort: false
    };
    var GridStack = class _GridStack {
      /**
       * Construct a grid item from the given element and options
       * @param el
       * @param opts
       */
      constructor(el, opts = {}) {
        this._gsEventHandler = {};
        this._extraDragRow = 0;
        this.el = el;
        opts = opts || {};
        if (opts.row) {
          opts.minRow = opts.maxRow = opts.row;
          delete opts.row;
        }
        let rowAttr = utils_1.Utils.toNumber(el.getAttribute("gs-row"));
        if (opts.column === "auto") {
          delete opts.column;
        }
        let anyOpts = opts;
        if (anyOpts.minWidth !== void 0) {
          opts.oneColumnSize = opts.oneColumnSize || anyOpts.minWidth;
          delete anyOpts.minWidth;
        }
        let defaults = Object.assign(Object.assign({}, utils_1.Utils.cloneDeep(GridDefaults)), { column: utils_1.Utils.toNumber(el.getAttribute("gs-column")) || 12, minRow: rowAttr ? rowAttr : utils_1.Utils.toNumber(el.getAttribute("gs-min-row")) || 0, maxRow: rowAttr ? rowAttr : utils_1.Utils.toNumber(el.getAttribute("gs-max-row")) || 0, staticGrid: utils_1.Utils.toBool(el.getAttribute("gs-static")) || false, _styleSheetClass: "grid-stack-instance-" + (Math.random() * 1e4).toFixed(0), alwaysShowResizeHandle: opts.alwaysShowResizeHandle || false, resizable: {
          autoHide: !(opts.alwaysShowResizeHandle || false),
          handles: "se"
        }, draggable: {
          handle: (opts.handleClass ? "." + opts.handleClass : opts.handle ? opts.handle : "") || ".grid-stack-item-content",
          scroll: false,
          appendTo: "body"
        }, removableOptions: {
          accept: "." + (opts.itemClass || "grid-stack-item")
        } });
        if (el.getAttribute("gs-animate")) {
          defaults.animate = utils_1.Utils.toBool(el.getAttribute("gs-animate"));
        }
        this.opts = utils_1.Utils.defaults(opts, defaults);
        opts = null;
        this._initMargin();
        if (this.opts.column !== 1 && !this.opts.disableOneColumnMode && this._widthOrContainer() <= this.opts.oneColumnSize) {
          this._prevColumn = this.getColumn();
          this.opts.column = 1;
        }
        if (this.opts.rtl === "auto") {
          this.opts.rtl = el.style.direction === "rtl";
        }
        if (this.opts.rtl) {
          this.el.classList.add("grid-stack-rtl");
        }
        let parentGridItemEl = utils_1.Utils.closestByClass(this.el, GridDefaults.itemClass);
        if (parentGridItemEl && parentGridItemEl.gridstackNode) {
          this.opts._isNested = parentGridItemEl.gridstackNode;
          this.opts._isNested.subGrid = this;
          parentGridItemEl.classList.add("grid-stack-nested");
          this.el.classList.add("grid-stack-nested");
        }
        this._isAutoCellHeight = this.opts.cellHeight === "auto";
        if (this._isAutoCellHeight || this.opts.cellHeight === "initial") {
          this.cellHeight(void 0, false);
        } else {
          if (typeof this.opts.cellHeight == "number" && this.opts.cellHeightUnit && this.opts.cellHeightUnit !== GridDefaults.cellHeightUnit) {
            this.opts.cellHeight = this.opts.cellHeight + this.opts.cellHeightUnit;
            delete this.opts.cellHeightUnit;
          }
          this.cellHeight(this.opts.cellHeight, false);
        }
        this.el.classList.add(this.opts._styleSheetClass);
        this._setStaticClass();
        let engineClass = this.opts.engineClass || _GridStack.engineClass || gridstack_engine_1.GridStackEngine;
        this.engine = new engineClass({
          column: this.getColumn(),
          float: this.opts.float,
          maxRow: this.opts.maxRow,
          onChange: (cbNodes) => {
            let maxH = 0;
            this.engine.nodes.forEach((n) => {
              maxH = Math.max(maxH, n.y + n.h);
            });
            cbNodes.forEach((n) => {
              let el2 = n.el;
              if (!el2)
                return;
              if (n._removeDOM) {
                if (el2)
                  el2.remove();
                delete n._removeDOM;
              } else {
                this._writePosAttr(el2, n);
              }
            });
            this._updateStyles(false, maxH);
          }
        });
        if (this.opts.auto) {
          this.batchUpdate();
          let elements = [];
          this.getGridItems().forEach((el2) => {
            let x = parseInt(el2.getAttribute("gs-x"));
            let y = parseInt(el2.getAttribute("gs-y"));
            elements.push({
              el: el2,
              // if x,y are missing (autoPosition) add them to end of list - but keep their respective DOM order
              i: (Number.isNaN(x) ? 1e3 : x) + (Number.isNaN(y) ? 1e3 : y) * this.getColumn()
            });
          });
          elements.sort((a, b) => a.i - b.i).forEach((e) => this._prepareElement(e.el));
          this.commit();
        }
        this.setAnimation(this.opts.animate);
        this._updateStyles();
        if (this.opts.column != 12) {
          this.el.classList.add("grid-stack-" + this.opts.column);
        }
        if (this.opts.dragIn)
          _GridStack.setupDragIn(this.opts.dragIn, this.opts.dragInOptions);
        delete this.opts.dragIn;
        delete this.opts.dragInOptions;
        this._setupRemoveDrop();
        this._setupAcceptWidget();
        this._updateWindowResizeEvent();
      }
      /**
       * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will
       * simply return the existing instance (ignore any passed options). There is also an initAll() version that support
       * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.
       * @param options grid options (optional)
       * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)
       *
       * @example
       * let grid = GridStack.init();
       *
       * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later
       * let grid = document.querySelector('.grid-stack').gridstack;
       */
      static init(options = {}, elOrString = ".grid-stack") {
        let el = _GridStack.getGridElement(elOrString);
        if (!el) {
          if (typeof elOrString === "string") {
            console.error('GridStack.initAll() no grid was found with selector "' + elOrString + '" - element missing or wrong selector ?\nNote: ".grid-stack" is required for proper CSS styling and drag/drop, and is the default selector.');
          } else {
            console.error("GridStack.init() no grid element was passed.");
          }
          return null;
        }
        if (!el.gridstack) {
          el.gridstack = new _GridStack(el, utils_1.Utils.cloneDeep(options));
        }
        return el.gridstack;
      }
      /**
       * Will initialize a list of elements (given a selector) and return an array of grids.
       * @param options grid options (optional)
       * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)
       *
       * @example
       * let grids = GridStack.initAll();
       * grids.forEach(...)
       */
      static initAll(options = {}, selector = ".grid-stack") {
        let grids = [];
        _GridStack.getGridElements(selector).forEach((el) => {
          if (!el.gridstack) {
            el.gridstack = new _GridStack(el, utils_1.Utils.cloneDeep(options));
            delete options.dragIn;
            delete options.dragInOptions;
          }
          grids.push(el.gridstack);
        });
        if (grids.length === 0) {
          console.error('GridStack.initAll() no grid was found with selector "' + selector + '" - element missing or wrong selector ?\nNote: ".grid-stack" is required for proper CSS styling and drag/drop, and is the default selector.');
        }
        return grids;
      }
      /**
       * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then
       * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from
       * JSON serialized data, including options.
       * @param parent HTML element parent to the grid
       * @param opt grids options used to initialize the grid, and list of children
       */
      static addGrid(parent, opt = {}) {
        if (!parent)
          return null;
        let el = parent;
        if (!parent.classList.contains("grid-stack")) {
          let doc = document.implementation.createHTMLDocument("");
          doc.body.innerHTML = `<div class="grid-stack ${opt.class || ""}"></div>`;
          el = doc.body.children[0];
          parent.appendChild(el);
        }
        let grid = _GridStack.init(opt, el);
        if (grid.opts.children) {
          let children = grid.opts.children;
          delete grid.opts.children;
          grid.load(children);
        }
        return grid;
      }
      /** call this method to register your engine instead of the default one.
       * See instead `GridStackOptions.engineClass` if you only need to
       * replace just one instance.
       */
      static registerEngine(engineClass) {
        _GridStack.engineClass = engineClass;
      }
      /** @internal create placeholder DIV as needed */
      get placeholder() {
        if (!this._placeholder) {
          let placeholderChild = document.createElement("div");
          placeholderChild.className = "placeholder-content";
          if (this.opts.placeholderText) {
            placeholderChild.innerHTML = this.opts.placeholderText;
          }
          this._placeholder = document.createElement("div");
          this._placeholder.classList.add(this.opts.placeholderClass, GridDefaults.itemClass, this.opts.itemClass);
          this.placeholder.appendChild(placeholderChild);
        }
        return this._placeholder;
      }
      /**
       * add a new widget and returns it.
       *
       * Widget will be always placed even if result height is more than actual grid height.
       * You need to use `willItFit()` before calling addWidget for additional check.
       * See also `makeWidget()`.
       *
       * @example
       * let grid = GridStack.init();
       * grid.addWidget({w: 3, content: 'hello'});
       * grid.addWidget('<div class="grid-stack-item"><div class="grid-stack-item-content">hello</div></div>', {w: 3});
       *
       * @param el  GridStackWidget (which can have content string as well), html element, or string definition to add
       * @param options widget position/size options (optional, and ignore if first param is already option) - see GridStackWidget
       */
      addWidget(els, options) {
        if (arguments.length > 2) {
          console.warn("gridstack.ts: `addWidget(el, x, y, width...)` is deprecated. Use `addWidget({x, y, w, content, ...})`. It will be removed soon");
          let a = arguments, i = 1, opt = {
            x: a[i++],
            y: a[i++],
            w: a[i++],
            h: a[i++],
            autoPosition: a[i++],
            minW: a[i++],
            maxW: a[i++],
            minH: a[i++],
            maxH: a[i++],
            id: a[i++]
          };
          return this.addWidget(els, opt);
        }
        function isGridStackWidget(w) {
          return w.x !== void 0 || w.y !== void 0 || w.w !== void 0 || w.h !== void 0 || w.content !== void 0 ? true : false;
        }
        let el;
        if (typeof els === "string") {
          let doc = document.implementation.createHTMLDocument("");
          doc.body.innerHTML = els;
          el = doc.body.children[0];
        } else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {
          let content = els ? els.content || "" : "";
          options = els;
          let doc = document.implementation.createHTMLDocument("");
          doc.body.innerHTML = `<div class="grid-stack-item ${this.opts.itemClass || ""}"><div class="grid-stack-item-content">${content}</div></div>`;
          el = doc.body.children[0];
        } else {
          el = els;
        }
        let domAttr = this._readAttr(el);
        options = utils_1.Utils.cloneDeep(options) || {};
        utils_1.Utils.defaults(options, domAttr);
        let node = this.engine.prepareNode(options);
        this._writeAttr(el, options);
        if (this._insertNotAppend) {
          this.el.prepend(el);
        } else {
          this.el.appendChild(el);
        }
        this._prepareElement(el, true, options);
        this._updateContainerHeight();
        if (node.subGrid && !node.subGrid.el) {
          let autoColumn;
          let ops = node.subGrid;
          if (ops.column === "auto") {
            ops.column = node.w;
            ops.disableOneColumnMode = true;
            autoColumn = true;
          }
          let content = node.el.querySelector(".grid-stack-item-content");
          node.subGrid = _GridStack.addGrid(content, node.subGrid);
          if (autoColumn) {
            node.subGrid._autoColumn = true;
          }
        }
        this._triggerAddEvent();
        this._triggerChangeEvent();
        return el;
      }
      /**
      /**
       * saves the current layout returning a list of widgets for serialization which might include any nested grids.
       * @param saveContent if true (default) the latest html inside .grid-stack-content will be saved to GridStackWidget.content field, else it will
       * be removed.
       * @param saveGridOpt if true (default false), save the grid options itself, so you can call the new GridStack.addGrid()
       * to recreate everything from scratch. GridStackOptions.children would then contain the widget list instead.
       * @returns list of widgets or full grid option, including .children list of widgets
       */
      save(saveContent = true, saveGridOpt = false) {
        let list = this.engine.save(saveContent);
        list.forEach((n) => {
          if (saveContent && n.el && !n.subGrid) {
            let sub = n.el.querySelector(".grid-stack-item-content");
            n.content = sub ? sub.innerHTML : void 0;
            if (!n.content)
              delete n.content;
          } else {
            if (!saveContent) {
              delete n.content;
            }
            if (n.subGrid) {
              n.subGrid = n.subGrid.save(saveContent, true);
            }
          }
          delete n.el;
        });
        if (saveGridOpt) {
          let o = utils_1.Utils.cloneDeep(this.opts);
          if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {
            o.margin = o.marginTop;
            delete o.marginTop;
            delete o.marginRight;
            delete o.marginBottom;
            delete o.marginLeft;
          }
          if (o.rtl === (this.el.style.direction === "rtl")) {
            o.rtl = "auto";
          }
          if (this._isAutoCellHeight) {
            o.cellHeight = "auto";
          }
          if (this._autoColumn) {
            o.column = "auto";
            delete o.disableOneColumnMode;
          }
          utils_1.Utils.removeInternalAndSame(o, GridDefaults);
          o.children = list;
          return o;
        }
        return list;
      }
      /**
       * load the widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.
       *
       * @param layout list of widgets definition to update/create
       * @param addAndRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving
       * the user control of insertion.
       *
       * @example
       * see http://gridstackjs.com/demo/serialization.html
       **/
      load(layout, addAndRemove = true) {
        let items = _GridStack.Utils.sort([...layout], -1, this._prevColumn || this.getColumn());
        this._insertNotAppend = true;
        if (this._prevColumn && this._prevColumn !== this.opts.column && items.some((n) => n.x + n.w > this.opts.column)) {
          this._ignoreLayoutsNodeChange = true;
          this.engine.cacheLayout(items, this._prevColumn, true);
        }
        let removed = [];
        this.batchUpdate();
        if (addAndRemove) {
          let copyNodes = [...this.engine.nodes];
          copyNodes.forEach((n) => {
            let item = items.find((w) => n.id === w.id);
            if (!item) {
              if (typeof addAndRemove === "function") {
                addAndRemove(this, n, false);
              } else {
                removed.push(n);
                this.removeWidget(n.el, true, false);
              }
            }
          });
        }
        items.forEach((w) => {
          let item = w.id || w.id === 0 ? this.engine.nodes.find((n) => n.id === w.id) : void 0;
          if (item) {
            this.update(item.el, w);
            if (w.subGrid && w.subGrid.children) {
              let sub = item.el.querySelector(".grid-stack");
              if (sub && sub.gridstack) {
                sub.gridstack.load(w.subGrid.children);
                this._insertNotAppend = true;
              }
            }
          } else if (addAndRemove) {
            if (typeof addAndRemove === "function") {
              w = addAndRemove(this, w, true).gridstackNode;
            } else {
              w = this.addWidget(w).gridstackNode;
            }
          }
        });
        this.engine.removedNodes = removed;
        this.commit();
        delete this._ignoreLayoutsNodeChange;
        delete this._insertNotAppend;
        return this;
      }
      /**
       * Initializes batch updates. You will see no changes until `commit()` method is called.
       */
      batchUpdate() {
        this.engine.batchUpdate();
        return this;
      }
      /**
       * Gets current cell height.
       */
      getCellHeight(forcePixel = false) {
        if (this.opts.cellHeight && this.opts.cellHeight !== "auto" && (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === "px")) {
          return this.opts.cellHeight;
        }
        let el = this.el.querySelector("." + this.opts.itemClass);
        if (el) {
          let height = utils_1.Utils.toNumber(el.getAttribute("gs-h"));
          return Math.round(el.offsetHeight / height);
        }
        let rows = parseInt(this.el.getAttribute("gs-current-row"));
        return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight;
      }
      /**
       * Update current cell height - see `GridStackOptions.cellHeight` for format.
       * This method rebuilds an internal CSS style sheet.
       * Note: You can expect performance issues if call this method too often.
       *
       * @param val the cell height. If not passed (undefined), cells content will be made square (match width minus margin),
       * if pass 0 the CSS will be generated by the application instead.
       * @param update (Optional) if false, styles will not be updated
       *
       * @example
       * grid.cellHeight(100); // same as 100px
       * grid.cellHeight('70px');
       * grid.cellHeight(grid.cellWidth() * 1.2);
       */
      cellHeight(val, update = true) {
        if (update && val !== void 0) {
          if (this._isAutoCellHeight !== (val === "auto")) {
            this._isAutoCellHeight = val === "auto";
            this._updateWindowResizeEvent();
          }
        }
        if (val === "initial" || val === "auto") {
          val = void 0;
        }
        if (val === void 0) {
          let marginDiff = -this.opts.marginRight - this.opts.marginLeft + this.opts.marginTop + this.opts.marginBottom;
          val = this.cellWidth() + marginDiff;
        }
        let data = utils_1.Utils.parseHeight(val);
        if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {
          return this;
        }
        this.opts.cellHeightUnit = data.unit;
        this.opts.cellHeight = data.h;
        if (update) {
          this._updateStyles(true, this.getRow());
        }
        return this;
      }
      /** Gets current cell width. */
      cellWidth() {
        return this._widthOrContainer() / this.getColumn();
      }
      /** return our expected width (or parent) for 1 column check */
      _widthOrContainer() {
        return this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth;
      }
      /**
       * Finishes batch updates. Updates DOM nodes. You must call it after batchUpdate.
       */
      commit() {
        this.engine.commit();
        this._triggerRemoveEvent();
        this._triggerAddEvent();
        this._triggerChangeEvent();
        return this;
      }
      /** re-layout grid items to reclaim any empty space */
      compact() {
        this.engine.compact();
        this._triggerChangeEvent();
        return this;
      }
      /**
       * set the number of columns in the grid. Will update existing widgets to conform to new number of columns,
       * as well as cache the original layout so you can revert back to previous positions without loss.
       * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11],
       * else you will need to generate correct CSS (see https://github.com/gridstack/gridstack.js#change-grid-columns)
       * @param column - Integer > 0 (default 12).
       * @param layout specify the type of re-layout that will happen (position, size, etc...).
       * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column
       */
      column(column, layout = "moveScale") {
        if (column < 1 || this.opts.column === column)
          return this;
        let oldColumn = this.getColumn();
        if (column === 1) {
          this._prevColumn = oldColumn;
        } else {
          delete this._prevColumn;
        }
        this.el.classList.remove("grid-stack-" + oldColumn);
        this.el.classList.add("grid-stack-" + column);
        this.opts.column = this.engine.column = column;
        let domNodes;
        if (column === 1 && this.opts.oneColumnModeDomSort) {
          domNodes = [];
          this.getGridItems().forEach((el) => {
            if (el.gridstackNode) {
              domNodes.push(el.gridstackNode);
            }
          });
          if (!domNodes.length) {
            domNodes = void 0;
          }
        }
        this.engine.updateNodeWidths(oldColumn, column, domNodes, layout);
        if (this._isAutoCellHeight)
          this.cellHeight();
        this._ignoreLayoutsNodeChange = true;
        this._triggerChangeEvent();
        delete this._ignoreLayoutsNodeChange;
        return this;
      }
      /**
       * get the number of columns in the grid (default 12)
       */
      getColumn() {
        return this.opts.column;
      }
      /** returns an array of grid HTML elements (no placeholder) - used to iterate through our children in DOM order */
      getGridItems() {
        return Array.from(this.el.children).filter((el) => el.matches("." + this.opts.itemClass) && !el.matches("." + this.opts.placeholderClass));
      }
      /**
       * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.
       * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).
       */
      destroy(removeDOM = true) {
        if (!this.el)
          return;
        this._updateWindowResizeEvent(true);
        this.setStatic(true, false);
        this.setAnimation(false);
        if (!removeDOM) {
          this.removeAll(removeDOM);
          this.el.classList.remove(this.opts._styleSheetClass);
        } else {
          this.el.parentNode.removeChild(this.el);
        }
        this._removeStylesheet();
        this.el.removeAttribute("gs-current-row");
        delete this.opts._isNested;
        delete this.opts;
        delete this._placeholder;
        delete this.engine;
        delete this.el.gridstack;
        delete this.el;
        return this;
      }
      /**
       * enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html)
       */
      float(val) {
        this.engine.float = val;
        this._triggerChangeEvent();
        return this;
      }
      /**
       * get the current float mode
       */
      getFloat() {
        return this.engine.float;
      }
      /**
       * Get the position of the cell under a pixel on screen.
       * @param position the position of the pixel to resolve in
       * absolute coordinates, as an object with top and left properties
       * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).
       * Useful when grid is within `position: relative` element
       *
       * Returns an object with properties `x` and `y` i.e. the column and row in the grid.
       */
      getCellFromPixel(position, useDocRelative = false) {
        let box = this.el.getBoundingClientRect();
        let containerPos;
        if (useDocRelative) {
          containerPos = { top: box.top + document.documentElement.scrollTop, left: box.left };
        } else {
          containerPos = { top: this.el.offsetTop, left: this.el.offsetLeft };
        }
        let relativeLeft = position.left - containerPos.left;
        let relativeTop = position.top - containerPos.top;
        let columnWidth = box.width / this.getColumn();
        let rowHeight = box.height / parseInt(this.el.getAttribute("gs-current-row"));
        return { x: Math.floor(relativeLeft / columnWidth), y: Math.floor(relativeTop / rowHeight) };
      }
      /** returns the current number of rows, which will be at least `minRow` if set */
      getRow() {
        return Math.max(this.engine.getRow(), this.opts.minRow);
      }
      /**
       * Checks if specified area is empty.
       * @param x the position x.
       * @param y the position y.
       * @param w the width of to check
       * @param h the height of to check
       */
      isAreaEmpty(x, y, w, h) {
        return this.engine.isAreaEmpty(x, y, w, h);
      }
      /**
       * If you add elements to your grid by hand, you have to tell gridstack afterwards to make them widgets.
       * If you want gridstack to add the elements for you, use `addWidget()` instead.
       * Makes the given element a widget and returns it.
       * @param els widget or single selector to convert.
       *
       * @example
       * let grid = GridStack.init();
       * grid.el.appendChild('<div id="gsi-1" gs-w="3"></div>');
       * grid.makeWidget('#gsi-1');
       */
      makeWidget(els) {
        let el = _GridStack.getElement(els);
        this._prepareElement(el, true);
        this._updateContainerHeight();
        this._triggerAddEvent();
        this._triggerChangeEvent();
        return el;
      }
      /**
       * Event handler that extracts our CustomEvent data out automatically for receiving custom
       * notifications (see doc for supported events)
       * @param name of the event (see possible values) or list of names space separated
       * @param callback function called with event and optional second/third param
       * (see README documentation for each signature).
       *
       * @example
       * grid.on('added', function(e, items) { log('added ', items)} );
       * or
       * grid.on('added removed change', function(e, items) { log(e.type, items)} );
       *
       * Note: in some cases it is the same as calling native handler and parsing the event.
       * grid.el.addEventListener('added', function(event) { log('added ', event.detail)} );
       *
       */
      on(name, callback) {
        if (name.indexOf(" ") !== -1) {
          let names = name.split(" ");
          names.forEach((name2) => this.on(name2, callback));
          return this;
        }
        if (name === "change" || name === "added" || name === "removed" || name === "enable" || name === "disable") {
          let noData = name === "enable" || name === "disable";
          if (noData) {
            this._gsEventHandler[name] = (event) => callback(event);
          } else {
            this._gsEventHandler[name] = (event) => callback(event, event.detail);
          }
          this.el.addEventListener(name, this._gsEventHandler[name]);
        } else if (name === "drag" || name === "dragstart" || name === "dragstop" || name === "resizestart" || name === "resize" || name === "resizestop" || name === "dropped") {
          this._gsEventHandler[name] = callback;
        } else {
          console.log("GridStack.on(" + name + ') event not supported, but you can still use $(".grid-stack").on(...) while jquery-ui is still used internally.');
        }
        return this;
      }
      /**
       * unsubscribe from the 'on' event below
       * @param name of the event (see possible values)
       */
      off(name) {
        if (name.indexOf(" ") !== -1) {
          let names = name.split(" ");
          names.forEach((name2) => this.off(name2));
          return this;
        }
        if (name === "change" || name === "added" || name === "removed" || name === "enable" || name === "disable") {
          if (this._gsEventHandler[name]) {
            this.el.removeEventListener(name, this._gsEventHandler[name]);
          }
        }
        delete this._gsEventHandler[name];
        return this;
      }
      /**
       * Removes widget from the grid.
       * @param el  widget or selector to modify
       * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).
       * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).
       */
      removeWidget(els, removeDOM = true, triggerEvent = true) {
        _GridStack.getElements(els).forEach((el) => {
          if (el.parentElement !== this.el)
            return;
          let node = el.gridstackNode;
          if (!node) {
            node = this.engine.nodes.find((n) => el === n.el);
          }
          if (!node)
            return;
          delete el.gridstackNode;
          gridstack_ddi_1.GridStackDDI.get().remove(el);
          this.engine.removeNode(node, removeDOM, triggerEvent);
          if (removeDOM && el.parentElement) {
            el.remove();
          }
        });
        if (triggerEvent) {
          this._triggerRemoveEvent();
          this._triggerChangeEvent();
        }
        return this;
      }
      /**
       * Removes all widgets from the grid.
       * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).
       */
      removeAll(removeDOM = true) {
        this.engine.nodes.forEach((n) => {
          delete n.el.gridstackNode;
          gridstack_ddi_1.GridStackDDI.get().remove(n.el);
        });
        this.engine.removeAll(removeDOM);
        this._triggerRemoveEvent();
        return this;
      }
      /**
       * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.
       * @param doAnimate if true the grid will animate.
       */
      setAnimation(doAnimate) {
        if (doAnimate) {
          this.el.classList.add("grid-stack-animate");
        } else {
          this.el.classList.remove("grid-stack-animate");
        }
        return this;
      }
      /**
       * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.
       * Also toggle the grid-stack-static class.
       * @param val if true the grid become static.
       */
      setStatic(val, updateClass = true) {
        if (this.opts.staticGrid === val)
          return this;
        this.opts.staticGrid = val;
        this._setupRemoveDrop();
        this._setupAcceptWidget();
        this.engine.nodes.forEach((n) => this._prepareDragDropByNode(n));
        if (updateClass) {
          this._setStaticClass();
        }
        return this;
      }
      /**
       * Updates widget position/size and other info. Note: if you need to call this on all nodes, use load() instead which will update what changed.
       * @param els  widget or selector of objects to modify (note: setting the same x,y for multiple items will be indeterministic and likely unwanted)
       * @param opt new widget options (x,y,w,h, etc..). Only those set will be updated.
       */
      update(els, opt) {
        if (arguments.length > 2) {
          console.warn("gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update(el, {x, w, content, ...})`. It will be removed soon");
          let a = arguments, i = 1;
          opt = { x: a[i++], y: a[i++], w: a[i++], h: a[i++] };
          return this.update(els, opt);
        }
        _GridStack.getElements(els).forEach((el) => {
          if (!el || !el.gridstackNode)
            return;
          let n = el.gridstackNode;
          let w = utils_1.Utils.cloneDeep(opt);
          delete w.autoPosition;
          let keys = ["x", "y", "w", "h"];
          let m;
          if (keys.some((k) => w[k] !== void 0 && w[k] !== n[k])) {
            m = {};
            keys.forEach((k) => {
              m[k] = w[k] !== void 0 ? w[k] : n[k];
              delete w[k];
            });
          }
          if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {
            m = {};
          }
          if (w.content) {
            let sub = el.querySelector(".grid-stack-item-content");
            if (sub && sub.innerHTML !== w.content) {
              sub.innerHTML = w.content;
            }
            delete w.content;
          }
          let changed = false;
          let ddChanged = false;
          for (const key in w) {
            if (key[0] !== "_" && n[key] !== w[key]) {
              n[key] = w[key];
              changed = true;
              ddChanged = ddChanged || !this.opts.staticGrid && (key === "noResize" || key === "noMove" || key === "locked");
            }
          }
          if (m) {
            this.engine.cleanNodes().beginUpdate(n).moveNode(n, m);
            this._updateContainerHeight();
            this._triggerChangeEvent();
            this.engine.endUpdate();
          }
          if (changed) {
            this._writeAttr(el, n);
          }
          if (ddChanged) {
            this._prepareDragDropByNode(n);
          }
        });
        return this;
      }
      /**
       * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options (CSS string format of 1,2,4 values or single number).
       * @param value margin value
       */
      margin(value) {
        let isMultiValue = typeof value === "string" && value.split(" ").length > 1;
        if (!isMultiValue) {
          let data = utils_1.Utils.parseHeight(value);
          if (this.opts.marginUnit === data.unit && this.opts.margin === data.h)
            return;
        }
        this.opts.margin = value;
        this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = void 0;
        this._initMargin();
        this._updateStyles(true);
        return this;
      }
      /** returns current margin number value (undefined if 4 sides don't match) */
      getMargin() {
        return this.opts.margin;
      }
      /**
       * Returns true if the height of the grid will be less than the vertical
       * constraint. Always returns true if grid doesn't have height constraint.
       * @param node contains x,y,w,h,auto-position options
       *
       * @example
       * if (grid.willItFit(newWidget)) {
       *   grid.addWidget(newWidget);
       * } else {
       *   alert('Not enough free space to place the widget');
       * }
       */
      willItFit(node) {
        if (arguments.length > 1) {
          console.warn("gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon");
          let a = arguments, i = 0, w = { x: a[i++], y: a[i++], w: a[i++], h: a[i++], autoPosition: a[i++] };
          return this.willItFit(w);
        }
        return this.engine.willItFit(node);
      }
      /** @internal */
      _triggerChangeEvent() {
        if (this.engine.batchMode)
          return this;
        let elements = this.engine.getDirtyNodes(true);
        if (elements && elements.length) {
          if (!this._ignoreLayoutsNodeChange) {
            this.engine.layoutsNodesChange(elements);
          }
          this._triggerEvent("change", elements);
        }
        this.engine.saveInitial();
        return this;
      }
      /** @internal */
      _triggerAddEvent() {
        if (this.engine.batchMode)
          return this;
        if (this.engine.addedNodes && this.engine.addedNodes.length > 0) {
          if (!this._ignoreLayoutsNodeChange) {
            this.engine.layoutsNodesChange(this.engine.addedNodes);
          }
          this.engine.addedNodes.forEach((n) => {
            delete n._dirty;
          });
          this._triggerEvent("added", this.engine.addedNodes);
          this.engine.addedNodes = [];
        }
        return this;
      }
      /** @internal */
      _triggerRemoveEvent() {
        if (this.engine.batchMode)
          return this;
        if (this.engine.removedNodes && this.engine.removedNodes.length > 0) {
          this._triggerEvent("removed", this.engine.removedNodes);
          this.engine.removedNodes = [];
        }
        return this;
      }
      /** @internal */
      _triggerEvent(name, data) {
        let event = data ? new CustomEvent(name, { bubbles: false, detail: data }) : new Event(name);
        this.el.dispatchEvent(event);
        return this;
      }
      /** @internal called to delete the current dynamic style sheet used for our layout */
      _removeStylesheet() {
        if (this._styles) {
          utils_1.Utils.removeStylesheet(this._styles._id);
          delete this._styles;
        }
        return this;
      }
      /** @internal updated/create the CSS styles for row based layout and initial margin setting */
      _updateStyles(forceUpdate = false, maxH) {
        if (forceUpdate) {
          this._removeStylesheet();
        }
        this._updateContainerHeight();
        if (this.opts.cellHeight === 0) {
          return this;
        }
        let cellHeight = this.opts.cellHeight;
        let cellHeightUnit = this.opts.cellHeightUnit;
        let prefix = `.${this.opts._styleSheetClass} > .${this.opts.itemClass}`;
        if (!this._styles) {
          let id = "gridstack-style-" + (Math.random() * 1e5).toFixed();
          let styleLocation = this.opts.styleInHead ? void 0 : this.el.parentNode;
          this._styles = utils_1.Utils.createStylesheet(id, styleLocation);
          if (!this._styles)
            return this;
          this._styles._id = id;
          this._styles._max = 0;
          utils_1.Utils.addCSSRule(this._styles, prefix, `min-height: ${cellHeight}${cellHeightUnit}`);
          let top = this.opts.marginTop + this.opts.marginUnit;
          let bottom = this.opts.marginBottom + this.opts.marginUnit;
          let right = this.opts.marginRight + this.opts.marginUnit;
          let left = this.opts.marginLeft + this.opts.marginUnit;
          let content = `${prefix} > .grid-stack-item-content`;
          let placeholder = `.${this.opts._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`;
          utils_1.Utils.addCSSRule(this._styles, content, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);
          utils_1.Utils.addCSSRule(this._styles, placeholder, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);
          utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-ne`, `right: ${right}`);
          utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-e`, `right: ${right}`);
          utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-se`, `right: ${right}; bottom: ${bottom}`);
          utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-nw`, `left: ${left}`);
          utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-w`, `left: ${left}`);
          utils_1.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-sw`, `left: ${left}; bottom: ${bottom}`);
        }
        maxH = maxH || this._styles._max;
        if (maxH > this._styles._max) {
          let getHeight = (rows) => cellHeight * rows + cellHeightUnit;
          for (let i = this._styles._max + 1; i <= maxH; i++) {
            let h = getHeight(i);
            utils_1.Utils.addCSSRule(this._styles, `${prefix}[gs-y="${i - 1}"]`, `top: ${getHeight(i - 1)}`);
            utils_1.Utils.addCSSRule(this._styles, `${prefix}[gs-h="${i}"]`, `height: ${h}`);
            utils_1.Utils.addCSSRule(this._styles, `${prefix}[gs-min-h="${i}"]`, `min-height: ${h}`);
            utils_1.Utils.addCSSRule(this._styles, `${prefix}[gs-max-h="${i}"]`, `max-height: ${h}`);
          }
          this._styles._max = maxH;
        }
        return this;
      }
      /** @internal */
      _updateContainerHeight() {
        if (!this.engine || this.engine.batchMode)
          return this;
        let row = this.getRow() + this._extraDragRow;
        this.el.setAttribute("gs-current-row", String(row));
        if (row === 0) {
          this.el.style.removeProperty("height");
          return this;
        }
        let cellHeight = this.opts.cellHeight;
        let unit = this.opts.cellHeightUnit;
        if (!cellHeight)
          return this;
        this.el.style.height = row * cellHeight + unit;
        return this;
      }
      /** @internal */
      _prepareElement(el, triggerAddEvent = false, node) {
        if (!node) {
          el.classList.add(this.opts.itemClass);
          node = this._readAttr(el);
        }
        el.gridstackNode = node;
        node.el = el;
        node.grid = this;
        let copy = Object.assign({}, node);
        node = this.engine.addNode(node, triggerAddEvent);
        if (!utils_1.Utils.same(node, copy)) {
          this._writeAttr(el, node);
        }
        this._prepareDragDropByNode(node);
        return this;
      }
      /** @internal call to write position x,y,w,h attributes back to element */
      _writePosAttr(el, n) {
        if (n.x !== void 0 && n.x !== null) {
          el.setAttribute("gs-x", String(n.x));
        }
        if (n.y !== void 0 && n.y !== null) {
          el.setAttribute("gs-y", String(n.y));
        }
        if (n.w) {
          el.setAttribute("gs-w", String(n.w));
        }
        if (n.h) {
          el.setAttribute("gs-h", String(n.h));
        }
        return this;
      }
      /** @internal call to write any default attributes back to element */
      _writeAttr(el, node) {
        if (!node)
          return this;
        this._writePosAttr(el, node);
        let attrs = {
          autoPosition: "gs-auto-position",
          minW: "gs-min-w",
          minH: "gs-min-h",
          maxW: "gs-max-w",
          maxH: "gs-max-h",
          noResize: "gs-no-resize",
          noMove: "gs-no-move",
          locked: "gs-locked",
          id: "gs-id",
          resizeHandles: "gs-resize-handles"
        };
        for (const key in attrs) {
          if (node[key]) {
            el.setAttribute(attrs[key], String(node[key]));
          } else {
            el.removeAttribute(attrs[key]);
          }
        }
        return this;
      }
      /** @internal call to read any default attributes from element */
      _readAttr(el) {
        let node = {};
        node.x = utils_1.Utils.toNumber(el.getAttribute("gs-x"));
        node.y = utils_1.Utils.toNumber(el.getAttribute("gs-y"));
        node.w = utils_1.Utils.toNumber(el.getAttribute("gs-w"));
        node.h = utils_1.Utils.toNumber(el.getAttribute("gs-h"));
        node.maxW = utils_1.Utils.toNumber(el.getAttribute("gs-max-w"));
        node.minW = utils_1.Utils.toNumber(el.getAttribute("gs-min-w"));
        node.maxH = utils_1.Utils.toNumber(el.getAttribute("gs-max-h"));
        node.minH = utils_1.Utils.toNumber(el.getAttribute("gs-min-h"));
        node.autoPosition = utils_1.Utils.toBool(el.getAttribute("gs-auto-position"));
        node.noResize = utils_1.Utils.toBool(el.getAttribute("gs-no-resize"));
        node.noMove = utils_1.Utils.toBool(el.getAttribute("gs-no-move"));
        node.locked = utils_1.Utils.toBool(el.getAttribute("gs-locked"));
        node.resizeHandles = el.getAttribute("gs-resize-handles");
        node.id = el.getAttribute("gs-id");
        for (const key in node) {
          if (!node.hasOwnProperty(key))
            return;
          if (!node[key] && node[key] !== 0) {
            delete node[key];
          }
        }
        return node;
      }
      /** @internal */
      _setStaticClass() {
        let classes = ["grid-stack-static"];
        if (this.opts.staticGrid) {
          this.el.classList.add(...classes);
          this.el.setAttribute("gs-static", "true");
        } else {
          this.el.classList.remove(...classes);
          this.el.removeAttribute("gs-static");
        }
        return this;
      }
      /**
       * called when we are being resized by the window - check if the one Column Mode needs to be turned on/off
       * and remember the prev columns we used, or get our count from parent, as well as check for auto cell height (square)
       */
      onParentResize() {
        if (!this.el || !this.el.clientWidth)
          return;
        let changedColumn = false;
        if (this._autoColumn && this.opts._isNested) {
          if (this.opts.column !== this.opts._isNested.w) {
            changedColumn = true;
            this.column(this.opts._isNested.w, "none");
          }
        } else {
          let oneColumn = !this.opts.disableOneColumnMode && this.el.clientWidth <= this.opts.oneColumnSize;
          if (this.opts.column === 1 !== oneColumn) {
            changedColumn = true;
            if (this.opts.animate) {
              this.setAnimation(false);
            }
            this.column(oneColumn ? 1 : this._prevColumn);
            if (this.opts.animate) {
              this.setAnimation(true);
            }
          }
        }
        if (this._isAutoCellHeight) {
          if (!changedColumn && this.opts.cellHeightThrottle) {
            if (!this._cellHeightThrottle) {
              this._cellHeightThrottle = utils_1.Utils.throttle(() => this.cellHeight(), this.opts.cellHeightThrottle);
            }
            this._cellHeightThrottle();
          } else {
            this.cellHeight();
          }
        }
        this.engine.nodes.forEach((n) => {
          if (n.subGrid) {
            n.subGrid.onParentResize();
          }
        });
        return this;
      }
      /** add or remove the window size event handler */
      _updateWindowResizeEvent(forceRemove = false) {
        const workTodo = (this._isAutoCellHeight || !this.opts.disableOneColumnMode) && !this.opts._isNested;
        if (!forceRemove && workTodo && !this._windowResizeBind) {
          this._windowResizeBind = this.onParentResize.bind(this);
          window.addEventListener("resize", this._windowResizeBind);
        } else if ((forceRemove || !workTodo) && this._windowResizeBind) {
          window.removeEventListener("resize", this._windowResizeBind);
          delete this._windowResizeBind;
        }
        return this;
      }
      /** @internal convert a potential selector into actual element */
      static getElement(els = ".grid-stack-item") {
        return utils_1.Utils.getElement(els);
      }
      /** @internal */
      static getElements(els = ".grid-stack-item") {
        return utils_1.Utils.getElements(els);
      }
      /** @internal */
      static getGridElement(els) {
        return _GridStack.getElement(els);
      }
      /** @internal */
      static getGridElements(els) {
        return utils_1.Utils.getElements(els);
      }
      /** @internal initialize margin top/bottom/left/right and units */
      _initMargin() {
        let data;
        let margin = 0;
        let margins = [];
        if (typeof this.opts.margin === "string") {
          margins = this.opts.margin.split(" ");
        }
        if (margins.length === 2) {
          this.opts.marginTop = this.opts.marginBottom = margins[0];
          this.opts.marginLeft = this.opts.marginRight = margins[1];
        } else if (margins.length === 4) {
          this.opts.marginTop = margins[0];
          this.opts.marginRight = margins[1];
          this.opts.marginBottom = margins[2];
          this.opts.marginLeft = margins[3];
        } else {
          data = utils_1.Utils.parseHeight(this.opts.margin);
          this.opts.marginUnit = data.unit;
          margin = this.opts.margin = data.h;
        }
        if (this.opts.marginTop === void 0) {
          this.opts.marginTop = margin;
        } else {
          data = utils_1.Utils.parseHeight(this.opts.marginTop);
          this.opts.marginTop = data.h;
          delete this.opts.margin;
        }
        if (this.opts.marginBottom === void 0) {
          this.opts.marginBottom = margin;
        } else {
          data = utils_1.Utils.parseHeight(this.opts.marginBottom);
          this.opts.marginBottom = data.h;
          delete this.opts.margin;
        }
        if (this.opts.marginRight === void 0) {
          this.opts.marginRight = margin;
        } else {
          data = utils_1.Utils.parseHeight(this.opts.marginRight);
          this.opts.marginRight = data.h;
          delete this.opts.margin;
        }
        if (this.opts.marginLeft === void 0) {
          this.opts.marginLeft = margin;
        } else {
          data = utils_1.Utils.parseHeight(this.opts.marginLeft);
          this.opts.marginLeft = data.h;
          delete this.opts.margin;
        }
        this.opts.marginUnit = data.unit;
        if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {
          this.opts.margin = this.opts.marginTop;
        }
        return this;
      }
      /*
       * drag&drop empty stubs that will be implemented in gridstack-dd.ts for non static grid
       * so we don't incur the load unless needed.
       * NOTE: had to make those methods public in order to define them else as
       *   GridStack.prototype._setupAcceptWidget = function()
       * maybe there is a better way ????
       */
      /* eslint-disable @typescript-eslint/no-unused-vars */
      /**
       * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.
       * Called during GridStack.init() as options, but can also be called directly (last param are cached) in case the toolbar
       * is dynamically create and needs to change later.
       * @param dragIn string selector (ex: '.sidebar .grid-stack-item')
       * @param dragInOptions options - see DDDragInOpt. (default: {revert: 'invalid', handle: '.grid-stack-item-content', scroll: false, appendTo: 'body'}
       **/
      static setupDragIn(dragIn, dragInOptions) {
      }
      /**
       * Enables/Disables dragging by the user of specific grid element. If you want all items, and have it affect future items, use enableMove() instead. No-op for static grids.
       * IF you are looking to prevent an item from moving (due to being pushed around by another during collision) use locked property instead.
       * @param els widget or selector to modify.
       * @param val if true widget will be draggable.
       */
      movable(els, val) {
        return this;
      }
      /**
       * Enables/Disables user resizing of specific grid element. If you want all items, and have it affect future items, use enableResize() instead. No-op for static grids.
       * @param els  widget or selector to modify
       * @param val  if true widget will be resizable.
       */
      resizable(els, val) {
        return this;
      }
      /**
       * Temporarily disables widgets moving/resizing.
       * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.
       * Note: no-op for static grid
       * This is a shortcut for:
       * @example
       *  grid.enableMove(false);
       *  grid.enableResize(false);
       */
      disable() {
        return this;
      }
      /**
       * Re-enables widgets moving/resizing - see disable().
       * Note: no-op for static grid.
       * This is a shortcut for:
       * @example
       *  grid.enableMove(true);
       *  grid.enableResize(true);
       */
      enable() {
        return this;
      }
      /**
       * Enables/disables widget moving. No-op for static grids.
       */
      enableMove(doEnable) {
        return this;
      }
      /**
       * Enables/disables widget resizing. No-op for static grids.
       */
      enableResize(doEnable) {
        return this;
      }
      /** @internal called to add drag over support to support widgets */
      _setupAcceptWidget() {
        return this;
      }
      /** @internal called to setup a trash drop zone if the user specifies it */
      _setupRemoveDrop() {
        return this;
      }
      /** @internal prepares the element for drag&drop **/
      _prepareDragDropByNode(node) {
        return this;
      }
      /** @internal handles actual drag/resize start **/
      _onStartMoving(el, event, ui, node, cellWidth, cellHeight) {
        return;
      }
      /** @internal handles actual drag/resize **/
      _dragOrResize(el, event, ui, node, cellWidth, cellHeight) {
        return;
      }
      /** @internal called when a node leaves our area (mouse out or shape outside) **/
      _leave(el, helper) {
        return;
      }
    };
    exports.GridStack = GridStack;
    GridStack.Utils = utils_1.Utils;
    GridStack.Engine = gridstack_engine_1.GridStackEngine;
  }
});

export {
  require_utils,
  require_gridstack_ddi,
  require_gridstack
};
/*! Bundled license information:

gridstack/dist/gridstack.js:
  (*!
   * GridStack 5.1.1
   * https://gridstackjs.com/
   *
   * Copyright (c) 2021-2022 Alain Dumesny
   * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE
   *)
*/
//# sourceMappingURL=chunk-DNUZAIDK.js.map

import {
  require_gridstack,
  require_gridstack_ddi,
  require_utils
} from "./chunk-DNUZAIDK.js";
import {
  __commonJS
} from "./chunk-ZS7NZCD4.js";

// node_modules/gridstack/dist/h5/dd-manager.js
var require_dd_manager = __commonJS({
  "node_modules/gridstack/dist/h5/dd-manager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DDManager = void 0;
    var DDManager = class {
    };
    exports.DDManager = DDManager;
  }
});

// node_modules/gridstack/dist/h5/dd-resizable-handle.js
var require_dd_resizable_handle = __commonJS({
  "node_modules/gridstack/dist/h5/dd-resizable-handle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DDResizableHandle = void 0;
    var DDResizableHandle = class _DDResizableHandle {
      constructor(host, direction, option) {
        this.moving = false;
        this.host = host;
        this.dir = direction;
        this.option = option;
        this._mouseDown = this._mouseDown.bind(this);
        this._mouseMove = this._mouseMove.bind(this);
        this._mouseUp = this._mouseUp.bind(this);
        this._init();
      }
      /** @internal */
      _init() {
        const el = document.createElement("div");
        el.classList.add("ui-resizable-handle");
        el.classList.add(`${_DDResizableHandle.prefix}${this.dir}`);
        el.style.zIndex = "100";
        el.style.userSelect = "none";
        this.el = el;
        this.host.appendChild(this.el);
        this.el.addEventListener("mousedown", this._mouseDown);
        return this;
      }
      /** call this when resize handle needs to be removed and cleaned up */
      destroy() {
        if (this.moving)
          this._mouseUp(this.mouseDownEvent);
        this.el.removeEventListener("mousedown", this._mouseDown);
        this.host.removeChild(this.el);
        delete this.el;
        delete this.host;
        return this;
      }
      /** @internal called on mouse down on us: capture move on the entire document (mouse might not stay on us) until we release the mouse */
      _mouseDown(e) {
        e.preventDefault();
        this.mouseDownEvent = e;
        document.addEventListener("mousemove", this._mouseMove, true);
        document.addEventListener("mouseup", this._mouseUp);
      }
      /** @internal */
      _mouseMove(e) {
        let s = this.mouseDownEvent;
        if (!this.moving && Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 2) {
          this.moving = true;
          this._triggerEvent("start", this.mouseDownEvent);
        } else if (this.moving) {
          this._triggerEvent("move", e);
        }
      }
      /** @internal */
      _mouseUp(e) {
        if (this.moving) {
          this._triggerEvent("stop", e);
        }
        document.removeEventListener("mousemove", this._mouseMove, true);
        document.removeEventListener("mouseup", this._mouseUp);
        delete this.moving;
        delete this.mouseDownEvent;
      }
      /** @internal */
      _triggerEvent(name, event) {
        if (this.option[name])
          this.option[name](event);
        return this;
      }
    };
    exports.DDResizableHandle = DDResizableHandle;
    DDResizableHandle.prefix = "ui-resizable-";
  }
});

// node_modules/gridstack/dist/h5/dd-base-impl.js
var require_dd_base_impl = __commonJS({
  "node_modules/gridstack/dist/h5/dd-base-impl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DDBaseImplement = void 0;
    var DDBaseImplement = class {
      constructor() {
        this._disabled = false;
        this._eventRegister = {};
      }
      /** returns the enable state, but you have to call enable()/disable() to change (as other things need to happen) */
      get disabled() {
        return this._disabled;
      }
      on(event, callback) {
        this._eventRegister[event] = callback;
      }
      off(event) {
        delete this._eventRegister[event];
      }
      enable() {
        this._disabled = false;
      }
      disable() {
        this._disabled = true;
      }
      destroy() {
        delete this._eventRegister;
      }
      triggerEvent(eventName, event) {
        if (!this.disabled && this._eventRegister && this._eventRegister[eventName])
          return this._eventRegister[eventName](event);
      }
    };
    exports.DDBaseImplement = DDBaseImplement;
  }
});

// node_modules/gridstack/dist/h5/dd-utils.js
var require_dd_utils = __commonJS({
  "node_modules/gridstack/dist/h5/dd-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DDUtils = void 0;
    var DDUtils = class {
      static clone(el) {
        const node = el.cloneNode(true);
        node.removeAttribute("id");
        return node;
      }
      static appendTo(el, parent) {
        let parentNode;
        if (typeof parent === "string") {
          parentNode = document.querySelector(parent);
        } else {
          parentNode = parent;
        }
        if (parentNode) {
          parentNode.appendChild(el);
        }
      }
      static setPositionRelative(el) {
        if (!/^(?:r|a|f)/.test(window.getComputedStyle(el).position)) {
          el.style.position = "relative";
        }
      }
      static addElStyles(el, styles) {
        if (styles instanceof Object) {
          for (const s in styles) {
            if (styles.hasOwnProperty(s)) {
              if (Array.isArray(styles[s])) {
                styles[s].forEach((val) => {
                  el.style[s] = val;
                });
              } else {
                el.style[s] = styles[s];
              }
            }
          }
        }
      }
      static initEvent(e, info) {
        const evt = { type: info.type };
        const obj = {
          button: 0,
          which: 0,
          buttons: 1,
          bubbles: true,
          cancelable: true,
          target: info.target ? info.target : e.target
        };
        if (e.dataTransfer) {
          evt["dataTransfer"] = e.dataTransfer;
        }
        ["altKey", "ctrlKey", "metaKey", "shiftKey"].forEach((p) => evt[p] = e[p]);
        ["pageX", "pageY", "clientX", "clientY", "screenX", "screenY"].forEach((p) => evt[p] = e[p]);
        return Object.assign(Object.assign({}, evt), obj);
      }
      /** returns true if event is inside the given element rectangle */
      // Note: Safari Mac has null event.relatedTarget which causes #1684 so check if DragEvent is inside the coordinates instead
      //    this.el.contains(event.relatedTarget as HTMLElement)
      static inside(e, el) {
        let target = e.relatedTarget || e.fromElement;
        if (!target) {
          const { bottom, left, right, top } = el.getBoundingClientRect();
          return e.x < right && e.x > left && e.y < bottom && e.y > top;
        }
        return el.contains(target);
      }
    };
    exports.DDUtils = DDUtils;
    DDUtils.isEventSupportPassiveOption = (() => {
      let supportsPassive = false;
      let passiveTest = () => {
      };
      document.addEventListener("test", passiveTest, {
        get passive() {
          supportsPassive = true;
          return true;
        }
      });
      document.removeEventListener("test", passiveTest);
      return supportsPassive;
    })();
  }
});

// node_modules/gridstack/dist/h5/dd-resizable.js
var require_dd_resizable = __commonJS({
  "node_modules/gridstack/dist/h5/dd-resizable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DDResizable = void 0;
    var dd_resizable_handle_1 = require_dd_resizable_handle();
    var dd_base_impl_1 = require_dd_base_impl();
    var dd_utils_1 = require_dd_utils();
    var utils_1 = require_utils();
    var DDResizable = class _DDResizable extends dd_base_impl_1.DDBaseImplement {
      constructor(el, opts = {}) {
        super();
        this._showHandlers = () => {
          this.el.classList.remove("ui-resizable-autohide");
        };
        this._hideHandlers = () => {
          this.el.classList.add("ui-resizable-autohide");
        };
        this._ui = () => {
          const containmentEl = this.el.parentElement;
          const containmentRect = containmentEl.getBoundingClientRect();
          const newRect = {
            width: this.originalRect.width,
            height: this.originalRect.height + this.scrolled,
            left: this.originalRect.left,
            top: this.originalRect.top - this.scrolled
          };
          const rect = this.temporalRect || newRect;
          return {
            position: {
              left: rect.left - containmentRect.left,
              top: rect.top - containmentRect.top
            },
            size: {
              width: rect.width,
              height: rect.height
            }
            /* Gridstack ONLY needs position set above... keep around in case.
            element: [this.el], // The object representing the element to be resized
            helper: [], // TODO: not support yet - The object representing the helper that's being resized
            originalElement: [this.el],// we don't wrap here, so simplify as this.el //The object representing the original element before it is wrapped
            originalPosition: { // The position represented as { left, top } before the resizable is resized
              left: this.originalRect.left - containmentRect.left,
              top: this.originalRect.top - containmentRect.top
            },
            originalSize: { // The size represented as { width, height } before the resizable is resized
              width: this.originalRect.width,
              height: this.originalRect.height
            }
            */
          };
        };
        this.el = el;
        this.option = opts;
        this.enable();
        this._setupAutoHide();
        this._setupHandlers();
      }
      on(event, callback) {
        super.on(event, callback);
      }
      off(event) {
        super.off(event);
      }
      enable() {
        super.enable();
        this.el.classList.add("ui-resizable");
        this.el.classList.remove("ui-resizable-disabled");
      }
      disable() {
        super.disable();
        this.el.classList.add("ui-resizable-disabled");
        this.el.classList.remove("ui-resizable");
      }
      destroy() {
        this._removeHandlers();
        if (this.option.autoHide) {
          this.el.removeEventListener("mouseover", this._showHandlers);
          this.el.removeEventListener("mouseout", this._hideHandlers);
        }
        this.el.classList.remove("ui-resizable");
        delete this.el;
        super.destroy();
      }
      updateOption(opts) {
        let updateHandles = opts.handles && opts.handles !== this.option.handles;
        let updateAutoHide = opts.autoHide && opts.autoHide !== this.option.autoHide;
        Object.keys(opts).forEach((key) => this.option[key] = opts[key]);
        if (updateHandles) {
          this._removeHandlers();
          this._setupHandlers();
        }
        if (updateAutoHide) {
          this._setupAutoHide();
        }
        return this;
      }
      /** @internal */
      _setupAutoHide() {
        if (this.option.autoHide) {
          this.el.classList.add("ui-resizable-autohide");
          this.el.addEventListener("mouseover", this._showHandlers);
          this.el.addEventListener("mouseout", this._hideHandlers);
        } else {
          this.el.classList.remove("ui-resizable-autohide");
          this.el.removeEventListener("mouseover", this._showHandlers);
          this.el.removeEventListener("mouseout", this._hideHandlers);
        }
        return this;
      }
      /** @internal */
      _setupHandlers() {
        let handlerDirection = this.option.handles || "e,s,se";
        if (handlerDirection === "all") {
          handlerDirection = "n,e,s,w,se,sw,ne,nw";
        }
        this.handlers = handlerDirection.split(",").map((dir) => dir.trim()).map((dir) => new dd_resizable_handle_1.DDResizableHandle(this.el, dir, {
          start: (event) => {
            this._resizeStart(event);
          },
          stop: (event) => {
            this._resizeStop(event);
          },
          move: (event) => {
            this._resizing(event, dir);
          }
        }));
        return this;
      }
      /** @internal */
      _resizeStart(event) {
        this.originalRect = this.el.getBoundingClientRect();
        this.scrollEl = utils_1.Utils.getScrollElement(this.el);
        this.scrollY = this.scrollEl.scrollTop;
        this.scrolled = 0;
        this.startEvent = event;
        this._setupHelper();
        this._applyChange();
        const ev = dd_utils_1.DDUtils.initEvent(event, { type: "resizestart", target: this.el });
        if (this.option.start) {
          this.option.start(ev, this._ui());
        }
        this.el.classList.add("ui-resizable-resizing");
        this.triggerEvent("resizestart", ev);
        return this;
      }
      /** @internal */
      _resizing(event, dir) {
        this.scrolled = this.scrollEl.scrollTop - this.scrollY;
        this.temporalRect = this._getChange(event, dir);
        this._applyChange();
        const ev = dd_utils_1.DDUtils.initEvent(event, { type: "resize", target: this.el });
        if (this.option.resize) {
          this.option.resize(ev, this._ui());
        }
        this.triggerEvent("resize", ev);
        return this;
      }
      /** @internal */
      _resizeStop(event) {
        const ev = dd_utils_1.DDUtils.initEvent(event, { type: "resizestop", target: this.el });
        if (this.option.stop) {
          this.option.stop(ev);
        }
        this.el.classList.remove("ui-resizable-resizing");
        this.triggerEvent("resizestop", ev);
        this._cleanHelper();
        delete this.startEvent;
        delete this.originalRect;
        delete this.temporalRect;
        delete this.scrollY;
        delete this.scrolled;
        return this;
      }
      /** @internal */
      _setupHelper() {
        this.elOriginStyleVal = _DDResizable._originStyleProp.map((prop) => this.el.style[prop]);
        this.parentOriginStylePosition = this.el.parentElement.style.position;
        if (window.getComputedStyle(this.el.parentElement).position.match(/static/)) {
          this.el.parentElement.style.position = "relative";
        }
        this.el.style.position = "absolute";
        this.el.style.opacity = "0.8";
        return this;
      }
      /** @internal */
      _cleanHelper() {
        _DDResizable._originStyleProp.forEach((prop, i) => {
          this.el.style[prop] = this.elOriginStyleVal[i] || null;
        });
        this.el.parentElement.style.position = this.parentOriginStylePosition || null;
        return this;
      }
      /** @internal */
      _getChange(event, dir) {
        const oEvent = this.startEvent;
        const newRect = {
          width: this.originalRect.width,
          height: this.originalRect.height + this.scrolled,
          left: this.originalRect.left,
          top: this.originalRect.top - this.scrolled
        };
        const offsetX = event.clientX - oEvent.clientX;
        const offsetY = event.clientY - oEvent.clientY;
        if (dir.indexOf("e") > -1) {
          newRect.width += offsetX;
        } else if (dir.indexOf("w") > -1) {
          newRect.width -= offsetX;
          newRect.left += offsetX;
        }
        if (dir.indexOf("s") > -1) {
          newRect.height += offsetY;
        } else if (dir.indexOf("n") > -1) {
          newRect.height -= offsetY;
          newRect.top += offsetY;
        }
        const constrain = this._constrainSize(newRect.width, newRect.height);
        if (Math.round(newRect.width) !== Math.round(constrain.width)) {
          if (dir.indexOf("w") > -1) {
            newRect.left += newRect.width - constrain.width;
          }
          newRect.width = constrain.width;
        }
        if (Math.round(newRect.height) !== Math.round(constrain.height)) {
          if (dir.indexOf("n") > -1) {
            newRect.top += newRect.height - constrain.height;
          }
          newRect.height = constrain.height;
        }
        return newRect;
      }
      /** @internal constrain the size to the set min/max values */
      _constrainSize(oWidth, oHeight) {
        const maxWidth = this.option.maxWidth || Number.MAX_SAFE_INTEGER;
        const minWidth = this.option.minWidth || oWidth;
        const maxHeight = this.option.maxHeight || Number.MAX_SAFE_INTEGER;
        const minHeight = this.option.minHeight || oHeight;
        const width = Math.min(maxWidth, Math.max(minWidth, oWidth));
        const height = Math.min(maxHeight, Math.max(minHeight, oHeight));
        return { width, height };
      }
      /** @internal */
      _applyChange() {
        let containmentRect = { left: 0, top: 0, width: 0, height: 0 };
        if (this.el.style.position === "absolute") {
          const containmentEl = this.el.parentElement;
          const { left, top } = containmentEl.getBoundingClientRect();
          containmentRect = { left, top, width: 0, height: 0 };
        }
        if (!this.temporalRect)
          return this;
        Object.keys(this.temporalRect).forEach((key) => {
          const value = this.temporalRect[key];
          this.el.style[key] = value - containmentRect[key] + "px";
        });
        return this;
      }
      /** @internal */
      _removeHandlers() {
        this.handlers.forEach((handle) => handle.destroy());
        delete this.handlers;
        return this;
      }
    };
    exports.DDResizable = DDResizable;
    DDResizable._originStyleProp = ["width", "height", "position", "left", "top", "opacity", "zIndex"];
  }
});

// node_modules/gridstack/dist/h5/dd-draggable.js
var require_dd_draggable = __commonJS({
  "node_modules/gridstack/dist/h5/dd-draggable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DDDraggable = void 0;
    var dd_manager_1 = require_dd_manager();
    var dd_utils_1 = require_dd_utils();
    var dd_base_impl_1 = require_dd_base_impl();
    var DDDraggable = class _DDDraggable extends dd_base_impl_1.DDBaseImplement {
      constructor(el, option = {}) {
        super();
        this.dragging = false;
        this.ui = () => {
          const containmentEl = this.el.parentElement;
          const containmentRect = containmentEl.getBoundingClientRect();
          const offset = this.helper.getBoundingClientRect();
          return {
            position: {
              top: offset.top - containmentRect.top,
              left: offset.left - containmentRect.left
            }
            /* not used by GridStack for now...
            helper: [this.helper], //The object arr representing the helper that's being dragged.
            offset: { top: offset.top, left: offset.left } // Current offset position of the helper as { top, left } object.
            */
          };
        };
        this.el = el;
        this.option = option;
        let className = option.handle.substring(1);
        this.dragEl = el.classList.contains(className) ? el : el.querySelector(option.handle) || el;
        this._dragStart = this._dragStart.bind(this);
        this._drag = this._drag.bind(this);
        this._dragEnd = this._dragEnd.bind(this);
        this.enable();
      }
      on(event, callback) {
        super.on(event, callback);
      }
      off(event) {
        super.off(event);
      }
      enable() {
        super.enable();
        this.dragEl.draggable = true;
        this.dragEl.addEventListener("dragstart", this._dragStart);
        this.el.classList.remove("ui-draggable-disabled");
        this.el.classList.add("ui-draggable");
      }
      disable(forDestroy = false) {
        super.disable();
        this.dragEl.removeAttribute("draggable");
        this.dragEl.removeEventListener("dragstart", this._dragStart);
        this.el.classList.remove("ui-draggable");
        if (!forDestroy)
          this.el.classList.add("ui-draggable-disabled");
      }
      destroy() {
        if (this.dragging) {
          this._dragEnd({});
        }
        this.disable(true);
        delete this.el;
        delete this.helper;
        delete this.option;
        super.destroy();
      }
      updateOption(opts) {
        Object.keys(opts).forEach((key) => this.option[key] = opts[key]);
        return this;
      }
      /** @internal */
      _dragStart(event) {
        dd_manager_1.DDManager.dragElement = this;
        this.helper = this._createHelper(event);
        this._setupHelperContainmentStyle();
        this.dragOffset = this._getDragOffset(event, this.el, this.helperContainment);
        const ev = dd_utils_1.DDUtils.initEvent(event, { target: this.el, type: "dragstart" });
        if (this.helper !== this.el) {
          this._setupDragFollowNodeNotifyStart(ev);
          this._dragFollow(event);
        } else {
          this.dragFollowTimer = window.setTimeout(() => {
            delete this.dragFollowTimer;
            this._setupDragFollowNodeNotifyStart(ev);
          }, 0);
        }
        this._cancelDragGhost(event);
      }
      /** @internal */
      _setupDragFollowNodeNotifyStart(ev) {
        this._setupHelperStyle();
        document.addEventListener("dragover", this._drag, _DDDraggable.dragEventListenerOption);
        this.dragEl.addEventListener("dragend", this._dragEnd);
        if (this.option.start) {
          this.option.start(ev, this.ui());
        }
        this.dragging = true;
        this.helper.classList.add("ui-draggable-dragging");
        this.triggerEvent("dragstart", ev);
        return this;
      }
      /** @internal */
      _drag(event) {
        event.preventDefault();
        this._dragFollow(event);
        const ev = dd_utils_1.DDUtils.initEvent(event, { target: this.el, type: "drag" });
        if (this.option.drag) {
          this.option.drag(ev, this.ui());
        }
        this.triggerEvent("drag", ev);
      }
      /** @internal */
      _dragEnd(event) {
        if (this.dragFollowTimer) {
          clearTimeout(this.dragFollowTimer);
          delete this.dragFollowTimer;
          return;
        } else {
          if (this.paintTimer) {
            cancelAnimationFrame(this.paintTimer);
          }
          document.removeEventListener("dragover", this._drag, _DDDraggable.dragEventListenerOption);
          this.dragEl.removeEventListener("dragend", this._dragEnd);
        }
        this.dragging = false;
        this.helper.classList.remove("ui-draggable-dragging");
        this.helperContainment.style.position = this.parentOriginStylePosition || null;
        if (this.helper === this.el) {
          this._removeHelperStyle();
        } else {
          this.helper.remove();
        }
        const ev = dd_utils_1.DDUtils.initEvent(event, { target: this.el, type: "dragstop" });
        if (this.option.stop) {
          this.option.stop(ev);
        }
        this.triggerEvent("dragstop", ev);
        delete dd_manager_1.DDManager.dragElement;
        delete this.helper;
      }
      /** @internal create a clone copy (or user defined method) of the original drag item if set */
      _createHelper(event) {
        let helper = this.el;
        if (typeof this.option.helper === "function") {
          helper = this.option.helper(event);
        } else if (this.option.helper === "clone") {
          helper = dd_utils_1.DDUtils.clone(this.el);
        }
        if (!document.body.contains(helper)) {
          dd_utils_1.DDUtils.appendTo(helper, this.option.appendTo === "parent" ? this.el.parentNode : this.option.appendTo);
        }
        if (helper === this.el) {
          this.dragElementOriginStyle = _DDDraggable.originStyleProp.map((prop) => this.el.style[prop]);
        }
        return helper;
      }
      /** @internal */
      _setupHelperStyle() {
        const rec = this.helper.getBoundingClientRect();
        const style = this.helper.style;
        style.pointerEvents = "none";
        style["min-width"] = 0;
        style.width = this.dragOffset.width + "px";
        style.height = this.dragOffset.height + "px";
        style.willChange = "left, top";
        style.position = "fixed";
        style.left = rec.left + "px";
        style.top = rec.top + "px";
        style.transition = "none";
        setTimeout(() => {
          if (this.helper) {
            style.transition = null;
          }
        }, 0);
        return this;
      }
      /** @internal */
      _removeHelperStyle() {
        var _a;
        let node = (_a = this.helper) === null || _a === void 0 ? void 0 : _a.gridstackNode;
        if (this.dragElementOriginStyle && (!node || !node._isAboutToRemove)) {
          let helper = this.helper;
          let transition = this.dragElementOriginStyle["transition"] || null;
          helper.style.transition = this.dragElementOriginStyle["transition"] = "none";
          _DDDraggable.originStyleProp.forEach((prop) => helper.style[prop] = this.dragElementOriginStyle[prop] || null);
          setTimeout(() => helper.style.transition = transition, 50);
        }
        delete this.dragElementOriginStyle;
        return this;
      }
      /** @internal */
      _dragFollow(event) {
        if (this.paintTimer) {
          cancelAnimationFrame(this.paintTimer);
        }
        this.paintTimer = requestAnimationFrame(() => {
          delete this.paintTimer;
          const offset = this.dragOffset;
          let containmentRect = { left: 0, top: 0 };
          if (this.helper.style.position === "absolute") {
            const { left, top } = this.helperContainment.getBoundingClientRect();
            containmentRect = { left, top };
          }
          this.helper.style.left = event.clientX + offset.offsetLeft - containmentRect.left + "px";
          this.helper.style.top = event.clientY + offset.offsetTop - containmentRect.top + "px";
        });
      }
      /** @internal */
      _setupHelperContainmentStyle() {
        this.helperContainment = this.helper.parentElement;
        if (this.helper.style.position !== "fixed") {
          this.parentOriginStylePosition = this.helperContainment.style.position;
          if (window.getComputedStyle(this.helperContainment).position.match(/static/)) {
            this.helperContainment.style.position = "relative";
          }
        }
        return this;
      }
      /** @internal prevent the default ghost image to be created (which has wrong as we move the helper/element instead
       * (legacy jquery UI code updates the top/left of the item).
       * TODO: maybe use mouse event instead of HTML5 drag as we have to work around it anyway, or change code to not update
       * the actual grid-item but move the ghost image around (and special case jq version) ?
       **/
      _cancelDragGhost(e) {
        let img = document.createElement("div");
        img.style.width = "1px";
        img.style.height = "1px";
        img.style.position = "fixed";
        document.body.appendChild(img);
        e.dataTransfer.setDragImage(img, 0, 0);
        setTimeout(() => document.body.removeChild(img));
        e.stopPropagation();
        return this;
      }
      /** @internal */
      _getDragOffset(event, el, parent) {
        let xformOffsetX = 0;
        let xformOffsetY = 0;
        if (parent) {
          const testEl = document.createElement("div");
          dd_utils_1.DDUtils.addElStyles(testEl, {
            opacity: "0",
            position: "fixed",
            top: "0px",
            left: "0px",
            width: "1px",
            height: "1px",
            zIndex: "-999999"
          });
          parent.appendChild(testEl);
          const testElPosition = testEl.getBoundingClientRect();
          parent.removeChild(testEl);
          xformOffsetX = testElPosition.left;
          xformOffsetY = testElPosition.top;
        }
        const targetOffset = el.getBoundingClientRect();
        return {
          left: targetOffset.left,
          top: targetOffset.top,
          offsetLeft: -event.clientX + targetOffset.left - xformOffsetX,
          offsetTop: -event.clientY + targetOffset.top - xformOffsetY,
          width: targetOffset.width,
          height: targetOffset.height
        };
      }
    };
    exports.DDDraggable = DDDraggable;
    DDDraggable.dragEventListenerOption = true;
    DDDraggable.originStyleProp = [
      "transition",
      "pointerEvents",
      "position",
      "left",
      "top",
      "opacity",
      "zIndex",
      "width",
      "height",
      "willChange",
      "min-width"
    ];
  }
});

// node_modules/gridstack/dist/h5/dd-droppable.js
var require_dd_droppable = __commonJS({
  "node_modules/gridstack/dist/h5/dd-droppable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DDDroppable = void 0;
    var dd_manager_1 = require_dd_manager();
    var dd_base_impl_1 = require_dd_base_impl();
    var dd_utils_1 = require_dd_utils();
    var DDDroppable = class _DDDroppable extends dd_base_impl_1.DDBaseImplement {
      constructor(el, opts = {}) {
        super();
        this.el = el;
        this.option = opts;
        this._dragEnter = this._dragEnter.bind(this);
        this._dragOver = this._dragOver.bind(this);
        this._dragLeave = this._dragLeave.bind(this);
        this._drop = this._drop.bind(this);
        this.el.classList.add("ui-droppable");
        this.el.addEventListener("dragenter", this._dragEnter);
        this._setupAccept();
      }
      on(event, callback) {
        super.on(event, callback);
      }
      off(event) {
        super.off(event);
      }
      enable() {
        if (!this.disabled)
          return;
        super.enable();
        this.el.classList.remove("ui-droppable-disabled");
        this.el.addEventListener("dragenter", this._dragEnter);
      }
      disable(forDestroy = false) {
        if (this.disabled)
          return;
        super.disable();
        if (!forDestroy)
          this.el.classList.add("ui-droppable-disabled");
        this.el.removeEventListener("dragenter", this._dragEnter);
      }
      destroy() {
        this._removeLeaveCallbacks();
        this.disable(true);
        this.el.classList.remove("ui-droppable");
        this.el.classList.remove("ui-droppable-disabled");
        super.destroy();
      }
      updateOption(opts) {
        Object.keys(opts).forEach((key) => this.option[key] = opts[key]);
        this._setupAccept();
        return this;
      }
      /** @internal called when the cursor enters our area - prepare for a possible drop and track leaving */
      _dragEnter(event) {
        if (!this._canDrop())
          return;
        event.preventDefault();
        event.stopPropagation();
        if (this.moving)
          return;
        this.moving = true;
        const ev = dd_utils_1.DDUtils.initEvent(event, { target: this.el, type: "dropover" });
        if (this.option.over) {
          this.option.over(ev, this._ui(dd_manager_1.DDManager.dragElement));
        }
        this.triggerEvent("dropover", ev);
        this.el.addEventListener("dragover", this._dragOver);
        this.el.addEventListener("drop", this._drop);
        this.el.addEventListener("dragleave", this._dragLeave);
        if (_DDDroppable.lastActive && _DDDroppable.lastActive !== this) {
          _DDDroppable.lastActive._dragLeave(event, true);
        }
        _DDDroppable.lastActive = this;
      }
      /** @internal called when an moving to drop item is being dragged over - do nothing but eat the event */
      _dragOver(event) {
        event.preventDefault();
        event.stopPropagation();
      }
      /** @internal called when the item is leaving our area, stop tracking if we had moving item */
      _dragLeave(event, forceLeave) {
        var _a;
        event.preventDefault();
        event.stopPropagation();
        if (!forceLeave) {
          let onChild = dd_utils_1.DDUtils.inside(event, this.el);
          let drag = dd_manager_1.DDManager.dragElement.el;
          if (onChild && !((_a = drag.gridstackNode) === null || _a === void 0 ? void 0 : _a.subGrid)) {
            let nestedEl = this.el.gridstack.engine.nodes.filter((n) => n.subGrid).map((n) => n.subGrid.el);
            onChild = !nestedEl.some((el) => dd_utils_1.DDUtils.inside(event, el));
          }
          if (onChild)
            return;
        }
        if (this.moving) {
          const ev = dd_utils_1.DDUtils.initEvent(event, { target: this.el, type: "dropout" });
          if (this.option.out) {
            this.option.out(ev, this._ui(dd_manager_1.DDManager.dragElement));
          }
          this.triggerEvent("dropout", ev);
        }
        this._removeLeaveCallbacks();
        if (_DDDroppable.lastActive === this) {
          delete _DDDroppable.lastActive;
        }
      }
      /** @internal item is being dropped on us - call the client drop event */
      _drop(event) {
        if (!this.moving)
          return;
        event.preventDefault();
        const ev = dd_utils_1.DDUtils.initEvent(event, { target: this.el, type: "drop" });
        if (this.option.drop) {
          this.option.drop(ev, this._ui(dd_manager_1.DDManager.dragElement));
        }
        this.triggerEvent("drop", ev);
        this._removeLeaveCallbacks();
      }
      /** @internal called to remove callbacks when leaving or dropping */
      _removeLeaveCallbacks() {
        if (!this.moving) {
          return;
        }
        delete this.moving;
        this.el.removeEventListener("dragover", this._dragOver);
        this.el.removeEventListener("drop", this._drop);
        this.el.removeEventListener("dragleave", this._dragLeave);
      }
      /** @internal */
      _canDrop() {
        return dd_manager_1.DDManager.dragElement && (!this.accept || this.accept(dd_manager_1.DDManager.dragElement.el));
      }
      /** @internal */
      _setupAccept() {
        if (this.option.accept && typeof this.option.accept === "string") {
          this.accept = (el) => {
            return el.matches(this.option.accept);
          };
        } else {
          this.accept = this.option.accept;
        }
        return this;
      }
      /** @internal */
      _ui(drag) {
        return Object.assign({ draggable: drag.el }, drag.ui());
      }
    };
    exports.DDDroppable = DDDroppable;
  }
});

// node_modules/gridstack/dist/h5/dd-element.js
var require_dd_element = __commonJS({
  "node_modules/gridstack/dist/h5/dd-element.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DDElement = void 0;
    var dd_resizable_1 = require_dd_resizable();
    var dd_draggable_1 = require_dd_draggable();
    var dd_droppable_1 = require_dd_droppable();
    var DDElement = class _DDElement {
      constructor(el) {
        this.el = el;
      }
      static init(el) {
        if (!el.ddElement) {
          el.ddElement = new _DDElement(el);
        }
        return el.ddElement;
      }
      on(eventName, callback) {
        if (this.ddDraggable && ["drag", "dragstart", "dragstop"].indexOf(eventName) > -1) {
          this.ddDraggable.on(eventName, callback);
        } else if (this.ddDroppable && ["drop", "dropover", "dropout"].indexOf(eventName) > -1) {
          this.ddDroppable.on(eventName, callback);
        } else if (this.ddResizable && ["resizestart", "resize", "resizestop"].indexOf(eventName) > -1) {
          this.ddResizable.on(eventName, callback);
        }
        return this;
      }
      off(eventName) {
        if (this.ddDraggable && ["drag", "dragstart", "dragstop"].indexOf(eventName) > -1) {
          this.ddDraggable.off(eventName);
        } else if (this.ddDroppable && ["drop", "dropover", "dropout"].indexOf(eventName) > -1) {
          this.ddDroppable.off(eventName);
        } else if (this.ddResizable && ["resizestart", "resize", "resizestop"].indexOf(eventName) > -1) {
          this.ddResizable.off(eventName);
        }
        return this;
      }
      setupDraggable(opts) {
        if (!this.ddDraggable) {
          this.ddDraggable = new dd_draggable_1.DDDraggable(this.el, opts);
        } else {
          this.ddDraggable.updateOption(opts);
        }
        return this;
      }
      cleanDraggable() {
        if (this.ddDraggable) {
          this.ddDraggable.destroy();
          delete this.ddDraggable;
        }
        return this;
      }
      setupResizable(opts) {
        if (!this.ddResizable) {
          this.ddResizable = new dd_resizable_1.DDResizable(this.el, opts);
        } else {
          this.ddResizable.updateOption(opts);
        }
        return this;
      }
      cleanResizable() {
        if (this.ddResizable) {
          this.ddResizable.destroy();
          delete this.ddResizable;
        }
        return this;
      }
      setupDroppable(opts) {
        if (!this.ddDroppable) {
          this.ddDroppable = new dd_droppable_1.DDDroppable(this.el, opts);
        } else {
          this.ddDroppable.updateOption(opts);
        }
        return this;
      }
      cleanDroppable() {
        if (this.ddDroppable) {
          this.ddDroppable.destroy();
          delete this.ddDroppable;
        }
        return this;
      }
    };
    exports.DDElement = DDElement;
  }
});

// node_modules/gridstack/dist/gridstack-dd.js
var require_gridstack_dd = __commonJS({
  "node_modules/gridstack/dist/gridstack-dd.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridStackDD = void 0;
    var gridstack_ddi_1 = require_gridstack_ddi();
    var gridstack_1 = require_gridstack();
    var utils_1 = require_utils();
    var GridStackDD = class extends gridstack_ddi_1.GridStackDDI {
      /** override to cast to correct type */
      static get() {
        return gridstack_ddi_1.GridStackDDI.get();
      }
      /** removes any drag&drop present (called during destroy) */
      remove(el) {
        this.draggable(el, "destroy").resizable(el, "destroy");
        if (el.gridstackNode) {
          delete el.gridstackNode._initDD;
        }
        return this;
      }
    };
    exports.GridStackDD = GridStackDD;
    gridstack_1.GridStack.prototype._setupAcceptWidget = function() {
      if (this.opts.staticGrid || !this.opts.acceptWidgets && !this.opts.removable) {
        GridStackDD.get().droppable(this.el, "destroy");
        return this;
      }
      let cellHeight, cellWidth;
      let onDrag = (event, el, helper) => {
        let node = el.gridstackNode;
        if (!node)
          return;
        helper = helper || el;
        let parent = this.el.getBoundingClientRect();
        let { top, left } = helper.getBoundingClientRect();
        left -= parent.left;
        top -= parent.top;
        let ui = { position: { top, left } };
        if (node._temporaryRemoved) {
          node.x = Math.max(0, Math.round(left / cellWidth));
          node.y = Math.max(0, Math.round(top / cellHeight));
          delete node.autoPosition;
          this.engine.nodeBoundFix(node);
          if (!this.engine.willItFit(node)) {
            node.autoPosition = true;
            if (!this.engine.willItFit(node)) {
              GridStackDD.get().off(el, "drag");
              return;
            }
            if (node._willFitPos) {
              utils_1.Utils.copyPos(node, node._willFitPos);
              delete node._willFitPos;
            }
          }
          this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);
        } else {
          this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);
        }
      };
      GridStackDD.get().droppable(this.el, {
        accept: (el) => {
          let node = el.gridstackNode;
          if ((node === null || node === void 0 ? void 0 : node.grid) === this)
            return true;
          if (!this.opts.acceptWidgets)
            return false;
          if (node === null || node === void 0 ? void 0 : node.subGrid)
            return false;
          let canAccept = true;
          if (typeof this.opts.acceptWidgets === "function") {
            canAccept = this.opts.acceptWidgets(el);
          } else {
            let selector = this.opts.acceptWidgets === true ? ".grid-stack-item" : this.opts.acceptWidgets;
            canAccept = el.matches(selector);
          }
          if (canAccept && node && this.opts.maxRow) {
            let n = { w: node.w, h: node.h, minW: node.minW, minH: node.minH };
            canAccept = this.engine.willItFit(n);
          }
          return canAccept;
        }
      }).on(this.el, "dropover", (event, el, helper) => {
        let node = el.gridstackNode;
        if ((node === null || node === void 0 ? void 0 : node.grid) === this && !node._temporaryRemoved) {
          return false;
        }
        if ((node === null || node === void 0 ? void 0 : node.grid) && node.grid !== this && !node._temporaryRemoved) {
          let otherGrid = node.grid;
          otherGrid._leave(el, helper);
        }
        cellWidth = this.cellWidth();
        cellHeight = this.getCellHeight(true);
        if (!node) {
          node = this._readAttr(el);
        }
        if (!node.grid) {
          node._isExternal = true;
          el.gridstackNode = node;
        }
        helper = helper || el;
        let w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;
        let h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;
        if (node.grid && node.grid !== this) {
          if (!el._gridstackNodeOrig)
            el._gridstackNodeOrig = node;
          el.gridstackNode = node = Object.assign(Object.assign({}, node), { w, h, grid: this });
          this.engine.cleanupNode(node).nodeBoundFix(node);
          node._initDD = node._isExternal = // DOM needs to be re-parented on a drop
          node._temporaryRemoved = true;
        } else {
          node.w = w;
          node.h = h;
          node._temporaryRemoved = true;
        }
        _itemRemoving(node.el, false);
        GridStackDD.get().on(el, "drag", onDrag);
        onDrag(event, el, helper);
        return false;
      }).on(this.el, "dropout", (event, el, helper) => {
        let node = el.gridstackNode;
        if (!node)
          return false;
        if (!node.grid || node.grid === this) {
          this._leave(el, helper);
        }
        return false;
      }).on(this.el, "drop", (event, el, helper) => {
        let node = el.gridstackNode;
        if ((node === null || node === void 0 ? void 0 : node.grid) === this && !node._isExternal)
          return false;
        let wasAdded = !!this.placeholder.parentElement;
        this.placeholder.remove();
        let origNode = el._gridstackNodeOrig;
        delete el._gridstackNodeOrig;
        if (wasAdded && origNode && origNode.grid && origNode.grid !== this) {
          let oGrid = origNode.grid;
          oGrid.engine.removedNodes.push(origNode);
          oGrid._triggerRemoveEvent();
        }
        if (!node)
          return false;
        if (wasAdded) {
          this.engine.cleanupNode(node);
          node.grid = this;
        }
        GridStackDD.get().off(el, "drag");
        if (helper !== el) {
          helper.remove();
          el.gridstackNode = origNode;
          if (wasAdded) {
            el = el.cloneNode(true);
          }
        } else {
          el.remove();
          GridStackDD.get().remove(el);
        }
        if (!wasAdded)
          return false;
        el.gridstackNode = node;
        node.el = el;
        utils_1.Utils.copyPos(node, this._readAttr(this.placeholder));
        utils_1.Utils.removePositioningStyles(el);
        this._writeAttr(el, node);
        this.el.appendChild(el);
        this._updateContainerHeight();
        this.engine.addedNodes.push(node);
        this._triggerAddEvent();
        this._triggerChangeEvent();
        this.engine.endUpdate();
        if (this._gsEventHandler["dropped"]) {
          this._gsEventHandler["dropped"](Object.assign(Object.assign({}, event), { type: "dropped" }), origNode && origNode.grid ? origNode : void 0, node);
        }
        window.setTimeout(() => {
          if (node.el && node.el.parentElement) {
            this._prepareDragDropByNode(node);
          } else {
            this.engine.removeNode(node);
          }
        });
        return false;
      });
      return this;
    };
    function _itemRemoving(el, remove) {
      let node = el ? el.gridstackNode : void 0;
      if (!node || !node.grid)
        return;
      remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;
      remove ? el.classList.add("grid-stack-item-removing") : el.classList.remove("grid-stack-item-removing");
    }
    gridstack_1.GridStack.prototype._setupRemoveDrop = function() {
      if (!this.opts.staticGrid && typeof this.opts.removable === "string") {
        let trashEl = document.querySelector(this.opts.removable);
        if (!trashEl)
          return this;
        if (!GridStackDD.get().isDroppable(trashEl)) {
          GridStackDD.get().droppable(trashEl, this.opts.removableOptions).on(trashEl, "dropover", (event, el) => _itemRemoving(el, true)).on(trashEl, "dropout", (event, el) => _itemRemoving(el, false));
        }
      }
      return this;
    };
    gridstack_1.GridStack.setupDragIn = function(_dragIn, _dragInOptions) {
      let dragIn;
      let dragInOptions;
      const dragInDefaultOptions = {
        revert: "invalid",
        handle: ".grid-stack-item-content",
        scroll: false,
        appendTo: "body"
      };
      if (_dragIn) {
        dragIn = _dragIn;
        dragInOptions = Object.assign(Object.assign({}, dragInDefaultOptions), _dragInOptions || {});
      }
      if (typeof dragIn !== "string")
        return;
      let dd = GridStackDD.get();
      utils_1.Utils.getElements(dragIn).forEach((el) => {
        if (!dd.isDraggable(el))
          dd.dragIn(el, dragInOptions);
      });
    };
    gridstack_1.GridStack.prototype._prepareDragDropByNode = function(node) {
      let el = node.el;
      let dd = GridStackDD.get();
      if (this.opts.staticGrid || (node.noMove || this.opts.disableDrag) && (node.noResize || this.opts.disableResize)) {
        if (node._initDD) {
          dd.remove(el);
          delete node._initDD;
        }
        el.classList.add("ui-draggable-disabled", "ui-resizable-disabled");
        return this;
      }
      if (!node._initDD) {
        let cellWidth;
        let cellHeight;
        let onStartMoving = (event, ui) => {
          if (this._gsEventHandler[event.type]) {
            this._gsEventHandler[event.type](event, event.target);
          }
          cellWidth = this.cellWidth();
          cellHeight = this.getCellHeight(true);
          this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);
        };
        let dragOrResize = (event, ui) => {
          this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);
        };
        let onEndMoving = (event) => {
          this.placeholder.remove();
          delete node._moving;
          delete node._lastTried;
          let target = event.target;
          if (!target.gridstackNode || target.gridstackNode.grid !== this)
            return;
          node.el = target;
          if (node._isAboutToRemove) {
            let gridToNotify = el.gridstackNode.grid;
            if (gridToNotify._gsEventHandler[event.type]) {
              gridToNotify._gsEventHandler[event.type](event, target);
            }
            dd.remove(el);
            gridToNotify.engine.removedNodes.push(node);
            gridToNotify._triggerRemoveEvent();
            delete el.gridstackNode;
            delete node.el;
            el.remove();
          } else {
            if (!node._temporaryRemoved) {
              utils_1.Utils.removePositioningStyles(target);
              this._writePosAttr(target, node);
            } else {
              utils_1.Utils.removePositioningStyles(target);
              utils_1.Utils.copyPos(node, node._orig);
              this._writePosAttr(target, node);
              this.engine.addNode(node);
            }
            if (this._gsEventHandler[event.type]) {
              this._gsEventHandler[event.type](event, target);
            }
          }
          this._extraDragRow = 0;
          this._updateContainerHeight();
          this._triggerChangeEvent();
          this.engine.endUpdate();
        };
        dd.draggable(el, {
          start: onStartMoving,
          stop: onEndMoving,
          drag: dragOrResize
        }).resizable(el, {
          start: onStartMoving,
          stop: onEndMoving,
          resize: dragOrResize
        });
        node._initDD = true;
      }
      if (node.noMove || this.opts.disableDrag) {
        dd.draggable(el, "disable");
        el.classList.add("ui-draggable-disabled");
      } else {
        dd.draggable(el, "enable");
        el.classList.remove("ui-draggable-disabled");
      }
      if (node.noResize || this.opts.disableResize) {
        dd.resizable(el, "disable");
        el.classList.add("ui-resizable-disabled");
      } else {
        dd.resizable(el, "enable");
        el.classList.remove("ui-resizable-disabled");
      }
      return this;
    };
    gridstack_1.GridStack.prototype._onStartMoving = function(el, event, ui, node, cellWidth, cellHeight) {
      this.engine.cleanNodes().beginUpdate(node);
      this._writePosAttr(this.placeholder, node);
      this.el.appendChild(this.placeholder);
      node.el = this.placeholder;
      node._lastUiPosition = ui.position;
      node._prevYPix = ui.position.top;
      node._moving = event.type === "dragstart";
      delete node._lastTried;
      if (event.type === "dropover" && node._temporaryRemoved) {
        this.engine.addNode(node);
        node._moving = true;
      }
      this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop, this.opts.marginRight, this.opts.marginBottom, this.opts.marginLeft);
      if (event.type === "resizestart") {
        let dd = GridStackDD.get().resizable(el, "option", "minWidth", cellWidth * (node.minW || 1)).resizable(el, "option", "minHeight", cellHeight * (node.minH || 1));
        if (node.maxW) {
          dd.resizable(el, "option", "maxWidth", cellWidth * node.maxW);
        }
        if (node.maxH) {
          dd.resizable(el, "option", "maxHeight", cellHeight * node.maxH);
        }
      }
    };
    gridstack_1.GridStack.prototype._leave = function(el, helper) {
      let node = el.gridstackNode;
      if (!node)
        return;
      GridStackDD.get().off(el, "drag");
      if (node._temporaryRemoved)
        return;
      node._temporaryRemoved = true;
      this.engine.removeNode(node);
      node.el = node._isExternal && helper ? helper : el;
      if (this.opts.removable === true) {
        _itemRemoving(el, true);
      }
      if (el._gridstackNodeOrig) {
        el.gridstackNode = el._gridstackNodeOrig;
        delete el._gridstackNodeOrig;
      } else if (node._isExternal) {
        delete node.el;
        delete el.gridstackNode;
        this.engine.restoreInitial();
      }
    };
    gridstack_1.GridStack.prototype._dragOrResize = function(el, event, ui, node, cellWidth, cellHeight) {
      let p = Object.assign({}, node._orig);
      let resizing;
      let mLeft = this.opts.marginLeft, mRight = this.opts.marginRight, mTop = this.opts.marginTop, mBottom = this.opts.marginBottom;
      let mHeight = Math.round(cellHeight * 0.1), mWidth = Math.round(cellWidth * 0.1);
      mLeft = Math.min(mLeft, mWidth);
      mRight = Math.min(mRight, mWidth);
      mTop = Math.min(mTop, mHeight);
      mBottom = Math.min(mBottom, mHeight);
      if (event.type === "drag") {
        if (node._temporaryRemoved)
          return;
        let distance = ui.position.top - node._prevYPix;
        node._prevYPix = ui.position.top;
        utils_1.Utils.updateScrollPosition(el, ui.position, distance);
        let left = ui.position.left + (ui.position.left > node._lastUiPosition.left ? -mRight : mLeft);
        let top = ui.position.top + (ui.position.top > node._lastUiPosition.top ? -mBottom : mTop);
        p.x = Math.round(left / cellWidth);
        p.y = Math.round(top / cellHeight);
        let prev = this._extraDragRow;
        if (this.engine.collide(node, p)) {
          let row = this.getRow();
          let extra = Math.max(0, p.y + node.h - row);
          if (this.opts.maxRow && row + extra > this.opts.maxRow) {
            extra = Math.max(0, this.opts.maxRow - row);
          }
          this._extraDragRow = extra;
        } else
          this._extraDragRow = 0;
        if (this._extraDragRow !== prev)
          this._updateContainerHeight();
        if (node.x === p.x && node.y === p.y)
          return;
      } else if (event.type === "resize") {
        if (p.x < 0)
          return;
        utils_1.Utils.updateScrollResize(event, el, cellHeight);
        p.w = Math.round((ui.size.width - mLeft) / cellWidth);
        p.h = Math.round((ui.size.height - mTop) / cellHeight);
        if (node.w === p.w && node.h === p.h)
          return;
        if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h)
          return;
        let left = ui.position.left + mLeft;
        let top = ui.position.top + mTop;
        p.x = Math.round(left / cellWidth);
        p.y = Math.round(top / cellHeight);
        resizing = true;
      }
      node._lastTried = p;
      let rect = {
        x: ui.position.left + mLeft,
        y: ui.position.top + mTop,
        w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,
        h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom
      };
      if (this.engine.moveNodeCheck(node, Object.assign(Object.assign({}, p), { cellWidth, cellHeight, rect, resizing }))) {
        node._lastUiPosition = ui.position;
        this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);
        delete node._skipDown;
        if (resizing && node.subGrid) {
          node.subGrid.onParentResize();
        }
        this._extraDragRow = 0;
        this._updateContainerHeight();
        let target = event.target;
        this._writePosAttr(target, node);
        if (this._gsEventHandler[event.type]) {
          this._gsEventHandler[event.type](event, target);
        }
      }
    };
    gridstack_1.GridStack.prototype.movable = function(els, val) {
      if (this.opts.staticGrid)
        return this;
      gridstack_1.GridStack.getElements(els).forEach((el) => {
        let node = el.gridstackNode;
        if (!node)
          return;
        if (val)
          delete node.noMove;
        else
          node.noMove = true;
        this._prepareDragDropByNode(node);
      });
      return this;
    };
    gridstack_1.GridStack.prototype.resizable = function(els, val) {
      if (this.opts.staticGrid)
        return this;
      gridstack_1.GridStack.getElements(els).forEach((el) => {
        let node = el.gridstackNode;
        if (!node)
          return;
        if (val)
          delete node.noResize;
        else
          node.noResize = true;
        this._prepareDragDropByNode(node);
      });
      return this;
    };
    gridstack_1.GridStack.prototype.disable = function() {
      if (this.opts.staticGrid)
        return;
      this.enableMove(false);
      this.enableResize(false);
      this._triggerEvent("disable");
      return this;
    };
    gridstack_1.GridStack.prototype.enable = function() {
      if (this.opts.staticGrid)
        return;
      this.enableMove(true);
      this.enableResize(true);
      this._triggerEvent("enable");
      return this;
    };
    gridstack_1.GridStack.prototype.enableMove = function(doEnable) {
      if (this.opts.staticGrid)
        return this;
      this.opts.disableDrag = !doEnable;
      this.engine.nodes.forEach((n) => this.movable(n.el, doEnable));
      return this;
    };
    gridstack_1.GridStack.prototype.enableResize = function(doEnable) {
      if (this.opts.staticGrid)
        return this;
      this.opts.disableResize = !doEnable;
      this.engine.nodes.forEach((n) => this.resizable(n.el, doEnable));
      return this;
    };
  }
});

// node_modules/gridstack/dist/h5/gridstack-dd-native.js
var require_gridstack_dd_native = __commonJS({
  "node_modules/gridstack/dist/h5/gridstack-dd-native.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridStackDDNative = void 0;
    var dd_manager_1 = require_dd_manager();
    var dd_element_1 = require_dd_element();
    var gridstack_dd_1 = require_gridstack_dd();
    var utils_1 = require_utils();
    __exportStar(require_gridstack_dd(), exports);
    var GridStackDDNative = class extends gridstack_dd_1.GridStackDD {
      resizable(el, opts, key, value) {
        this._getDDElements(el).forEach((dEl) => {
          if (opts === "disable" || opts === "enable") {
            dEl.ddResizable && dEl.ddResizable[opts]();
          } else if (opts === "destroy") {
            dEl.ddResizable && dEl.cleanResizable();
          } else if (opts === "option") {
            dEl.setupResizable({ [key]: value });
          } else {
            const grid = dEl.el.gridstackNode.grid;
            let handles = dEl.el.getAttribute("gs-resize-handles") ? dEl.el.getAttribute("gs-resize-handles") : grid.opts.resizable.handles;
            dEl.setupResizable(Object.assign(Object.assign(Object.assign({}, grid.opts.resizable), { handles }), {
              start: opts.start,
              stop: opts.stop,
              resize: opts.resize
            }));
          }
        });
        return this;
      }
      draggable(el, opts, key, value) {
        this._getDDElements(el).forEach((dEl) => {
          if (opts === "disable" || opts === "enable") {
            dEl.ddDraggable && dEl.ddDraggable[opts]();
          } else if (opts === "destroy") {
            dEl.ddDraggable && dEl.cleanDraggable();
          } else if (opts === "option") {
            dEl.setupDraggable({ [key]: value });
          } else {
            const grid = dEl.el.gridstackNode.grid;
            dEl.setupDraggable(Object.assign(Object.assign({}, grid.opts.draggable), {
              containment: grid.opts._isNested && !grid.opts.dragOut ? grid.el.parentElement : grid.opts.draggable.containment || null,
              start: opts.start,
              stop: opts.stop,
              drag: opts.drag
            }));
          }
        });
        return this;
      }
      dragIn(el, opts) {
        this._getDDElements(el).forEach((dEl) => dEl.setupDraggable(opts));
        return this;
      }
      droppable(el, opts, key, value) {
        if (typeof opts.accept === "function" && !opts._accept) {
          opts._accept = opts.accept;
          opts.accept = (el2) => opts._accept(el2);
        }
        this._getDDElements(el).forEach((dEl) => {
          if (opts === "disable" || opts === "enable") {
            dEl.ddDroppable && dEl.ddDroppable[opts]();
          } else if (opts === "destroy") {
            if (dEl.ddDroppable) {
              dEl.cleanDroppable();
            }
          } else if (opts === "option") {
            dEl.setupDroppable({ [key]: value });
          } else {
            dEl.setupDroppable(opts);
          }
        });
        return this;
      }
      /** true if element is droppable */
      isDroppable(el) {
        return !!(el && el.ddElement && el.ddElement.ddDroppable && !el.ddElement.ddDroppable.disabled);
      }
      /** true if element is draggable */
      isDraggable(el) {
        return !!(el && el.ddElement && el.ddElement.ddDraggable && !el.ddElement.ddDraggable.disabled);
      }
      /** true if element is draggable */
      isResizable(el) {
        return !!(el && el.ddElement && el.ddElement.ddResizable && !el.ddElement.ddResizable.disabled);
      }
      on(el, name, callback) {
        this._getDDElements(el).forEach((dEl) => dEl.on(name, (event) => {
          callback(event, dd_manager_1.DDManager.dragElement ? dd_manager_1.DDManager.dragElement.el : event.target, dd_manager_1.DDManager.dragElement ? dd_manager_1.DDManager.dragElement.helper : null);
        }));
        return this;
      }
      off(el, name) {
        this._getDDElements(el).forEach((dEl) => dEl.off(name));
        return this;
      }
      /** @internal returns a list of DD elements, creating them on the fly by default */
      _getDDElements(els, create = true) {
        let hosts = utils_1.Utils.getElements(els);
        if (!hosts.length)
          return [];
        let list = hosts.map((e) => e.ddElement || (create ? dd_element_1.DDElement.init(e) : null));
        if (!create) {
          list.filter((d) => d);
        }
        return list;
      }
    };
    exports.GridStackDDNative = GridStackDDNative;
    gridstack_dd_1.GridStackDD.registerPlugin(GridStackDDNative);
  }
});
export default require_gridstack_dd_native();
//# sourceMappingURL=gridstack_dist_h5_gridstack-dd-native.js.map
